{"version":3,"names":[],"mappings":"","sources":["dragSort.js"],"sourcesContent":["/**!\r\n * Sortable 1.10.2\r\n * @author\tRubaXa   <trash@rubaxa.org>\r\n * @author\towenm    <owen23355@gmail.com>\r\n * @license MIT\r\n */\r\n(function (global, factory) {\r\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n        typeof define === 'function' && define.amd ? define(factory) :\r\n            (global = global || self, global.Sortable = factory());\r\n}(this, function () { 'use strict';\r\n\r\n    function _typeof(obj) {\r\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\r\n            _typeof = function (obj) {\r\n                return typeof obj;\r\n            };\r\n        } else {\r\n            _typeof = function (obj) {\r\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\r\n            };\r\n        }\r\n\r\n        return _typeof(obj);\r\n    }\r\n\r\n    function _defineProperty(obj, key, value) {\r\n        if (key in obj) {\r\n            Object.defineProperty(obj, key, {\r\n                value: value,\r\n                enumerable: true,\r\n                configurable: true,\r\n                writable: true\r\n            });\r\n        } else {\r\n            obj[key] = value;\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    function _extends() {\r\n        _extends = Object.assign || function (target) {\r\n            for (var i = 1; i < arguments.length; i++) {\r\n                var source = arguments[i];\r\n\r\n                for (var key in source) {\r\n                    if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n                        target[key] = source[key];\r\n                    }\r\n                }\r\n            }\r\n\r\n            return target;\r\n        };\r\n\r\n        return _extends.apply(this, arguments);\r\n    }\r\n\r\n    function _objectSpread(target) {\r\n        for (var i = 1; i < arguments.length; i++) {\r\n            var source = arguments[i] != null ? arguments[i] : {};\r\n            var ownKeys = Object.keys(source);\r\n\r\n            if (typeof Object.getOwnPropertySymbols === 'function') {\r\n                ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\r\n                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;\r\n                }));\r\n            }\r\n\r\n            ownKeys.forEach(function (key) {\r\n                _defineProperty(target, key, source[key]);\r\n            });\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    function _objectWithoutPropertiesLoose(source, excluded) {\r\n        if (source == null) return {};\r\n        var target = {};\r\n        var sourceKeys = Object.keys(source);\r\n        var key, i;\r\n\r\n        for (i = 0; i < sourceKeys.length; i++) {\r\n            key = sourceKeys[i];\r\n            if (excluded.indexOf(key) >= 0) continue;\r\n            target[key] = source[key];\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    function _objectWithoutProperties(source, excluded) {\r\n        if (source == null) return {};\r\n\r\n        var target = _objectWithoutPropertiesLoose(source, excluded);\r\n\r\n        var key, i;\r\n\r\n        if (Object.getOwnPropertySymbols) {\r\n            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\r\n\r\n            for (i = 0; i < sourceSymbolKeys.length; i++) {\r\n                key = sourceSymbolKeys[i];\r\n                if (excluded.indexOf(key) >= 0) continue;\r\n                if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\r\n                target[key] = source[key];\r\n            }\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    function _toConsumableArray(arr) {\r\n        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\r\n    }\r\n\r\n    function _arrayWithoutHoles(arr) {\r\n        if (Array.isArray(arr)) {\r\n            for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\r\n\r\n            return arr2;\r\n        }\r\n    }\r\n\r\n    function _iterableToArray(iter) {\r\n        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\r\n    }\r\n\r\n    function _nonIterableSpread() {\r\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\r\n    }\r\n\r\n    var version = \"1.10.2\";\r\n\r\n    function userAgent(pattern) {\r\n        if (typeof window !== 'undefined' && window.navigator) {\r\n            return !!\r\n                /*@__PURE__*/\r\n                navigator.userAgent.match(pattern);\r\n        }\r\n    }\r\n\r\n    var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\r\n    var Edge = userAgent(/Edge/i);\r\n    var FireFox = userAgent(/firefox/i);\r\n    var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\r\n    var IOS = userAgent(/iP(ad|od|hone)/i);\r\n    var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\r\n\r\n    var captureMode = {\r\n        capture: false,\r\n        passive: false\r\n    };\r\n\r\n    function on(el, event, fn) {\r\n        el.addEventListener(event, fn, !IE11OrLess && captureMode);\r\n    }\r\n\r\n    function off(el, event, fn) {\r\n        el.removeEventListener(event, fn, !IE11OrLess && captureMode);\r\n    }\r\n\r\n    function matches(\r\n        /**HTMLElement*/\r\n        el,\r\n        /**String*/\r\n        selector) {\r\n        if (!selector) return;\r\n        selector[0] === '>' && (selector = selector.substring(1));\r\n\r\n        if (el) {\r\n            try {\r\n                if (el.matches) {\r\n                    return el.matches(selector);\r\n                } else if (el.msMatchesSelector) {\r\n                    return el.msMatchesSelector(selector);\r\n                } else if (el.webkitMatchesSelector) {\r\n                    return el.webkitMatchesSelector(selector);\r\n                }\r\n            } catch (_) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function getParentOrHost(el) {\r\n        return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\r\n    }\r\n\r\n    function closest(\r\n        /**HTMLElement*/\r\n        el,\r\n        /**String*/\r\n        selector,\r\n        /**HTMLElement*/\r\n        ctx, includeCTX) {\r\n        if (el) {\r\n            ctx = ctx || document;\r\n\r\n            do {\r\n                if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\r\n                    return el;\r\n                }\r\n\r\n                if (el === ctx) break;\r\n                /* jshint boss:true */\r\n            } while (el = getParentOrHost(el));\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    var R_SPACE = /\\s+/g;\r\n\r\n    function toggleClass(el, name, state) {\r\n        if (el && name) {\r\n            if (el.classList) {\r\n                el.classList[state ? 'add' : 'remove'](name);\r\n            } else {\r\n                var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\r\n                el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\r\n            }\r\n        }\r\n    }\r\n\r\n    function css(el, prop, val) {\r\n        var style = el && el.style;\r\n\r\n        if (style) {\r\n            if (val === void 0) {\r\n                if (document.defaultView && document.defaultView.getComputedStyle) {\r\n                    val = document.defaultView.getComputedStyle(el, '');\r\n                } else if (el.currentStyle) {\r\n                    val = el.currentStyle;\r\n                }\r\n\r\n                return prop === void 0 ? val : val[prop];\r\n            } else {\r\n                if (!(prop in style) && prop.indexOf('webkit') === -1) {\r\n                    prop = '-webkit-' + prop;\r\n                }\r\n\r\n                style[prop] = val + (typeof val === 'string' ? '' : 'px');\r\n            }\r\n        }\r\n    }\r\n\r\n    function matrix(el, selfOnly) {\r\n        var appliedTransforms = '';\r\n\r\n        if (typeof el === 'string') {\r\n            appliedTransforms = el;\r\n        } else {\r\n            do {\r\n                var transform = css(el, 'transform');\r\n\r\n                if (transform && transform !== 'none') {\r\n                    appliedTransforms = transform + ' ' + appliedTransforms;\r\n                }\r\n                /* jshint boss:true */\r\n\r\n            } while (!selfOnly && (el = el.parentNode));\r\n        }\r\n\r\n        var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\r\n        /*jshint -W056 */\r\n\r\n        return matrixFn && new matrixFn(appliedTransforms);\r\n    }\r\n\r\n    function find(ctx, tagName, iterator) {\r\n        if (ctx) {\r\n            var list = ctx.getElementsByTagName(tagName),\r\n                i = 0,\r\n                n = list.length;\r\n\r\n            if (iterator) {\r\n                for (; i < n; i++) {\r\n                    iterator(list[i], i);\r\n                }\r\n            }\r\n\r\n            return list;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    function getWindowScrollingElement() {\r\n        var scrollingElement = document.scrollingElement;\r\n\r\n        if (scrollingElement) {\r\n            return scrollingElement;\r\n        } else {\r\n            return document.documentElement;\r\n        }\r\n    }\r\n    /**\r\n     * Returns the \"bounding client rect\" of given element\r\n     * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\r\n     * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\r\n     * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\r\n     * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\r\n     * @param  {[HTMLElement]} container              The parent the element will be placed in\r\n     * @return {Object}                               The boundingClientRect of el, with specified adjustments\r\n     */\r\n\r\n\r\n    function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\r\n        if (!el.getBoundingClientRect && el !== window) return;\r\n        var elRect, top, left, bottom, right, height, width;\r\n\r\n        if (el !== window && el !== getWindowScrollingElement()) {\r\n            elRect = el.getBoundingClientRect();\r\n            top = elRect.top;\r\n            left = elRect.left;\r\n            bottom = elRect.bottom;\r\n            right = elRect.right;\r\n            height = elRect.height;\r\n            width = elRect.width;\r\n        } else {\r\n            top = 0;\r\n            left = 0;\r\n            bottom = window.innerHeight;\r\n            right = window.innerWidth;\r\n            height = window.innerHeight;\r\n            width = window.innerWidth;\r\n        }\r\n\r\n        if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\r\n            // Adjust for translate()\r\n            container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\r\n            // Not needed on <= IE11\r\n\r\n            if (!IE11OrLess) {\r\n                do {\r\n                    if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\r\n                        var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container\r\n\r\n                        top -= containerRect.top + parseInt(css(container, 'border-top-width'));\r\n                        left -= containerRect.left + parseInt(css(container, 'border-left-width'));\r\n                        bottom = top + elRect.height;\r\n                        right = left + elRect.width;\r\n                        break;\r\n                    }\r\n                    /* jshint boss:true */\r\n\r\n                } while (container = container.parentNode);\r\n            }\r\n        }\r\n\r\n        if (undoScale && el !== window) {\r\n            // Adjust for scale()\r\n            var elMatrix = matrix(container || el),\r\n                scaleX = elMatrix && elMatrix.a,\r\n                scaleY = elMatrix && elMatrix.d;\r\n\r\n            if (elMatrix) {\r\n                top /= scaleY;\r\n                left /= scaleX;\r\n                width /= scaleX;\r\n                height /= scaleY;\r\n                bottom = top + height;\r\n                right = left + width;\r\n            }\r\n        }\r\n\r\n        return {\r\n            top: top,\r\n            left: left,\r\n            bottom: bottom,\r\n            right: right,\r\n            width: width,\r\n            height: height\r\n        };\r\n    }\r\n    /**\r\n     * Checks if a side of an element is scrolled past a side of its parents\r\n     * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\r\n     * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\r\n     * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\r\n     * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\r\n     */\r\n\r\n\r\n    function isScrolledPast(el, elSide, parentSide) {\r\n        var parent = getParentAutoScrollElement(el, true),\r\n            elSideVal = getRect(el)[elSide];\r\n        /* jshint boss:true */\r\n\r\n        while (parent) {\r\n            var parentSideVal = getRect(parent)[parentSide],\r\n                visible = void 0;\r\n\r\n            if (parentSide === 'top' || parentSide === 'left') {\r\n                visible = elSideVal >= parentSideVal;\r\n            } else {\r\n                visible = elSideVal <= parentSideVal;\r\n            }\r\n\r\n            if (!visible) return parent;\r\n            if (parent === getWindowScrollingElement()) break;\r\n            parent = getParentAutoScrollElement(parent, false);\r\n        }\r\n\r\n        return false;\r\n    }\r\n    /**\r\n     * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\r\n     * and non-draggable elements\r\n     * @param  {HTMLElement} el       The parent element\r\n     * @param  {Number} childNum      The index of the child\r\n     * @param  {Object} options       Parent Sortable's options\r\n     * @return {HTMLElement}          The child at index childNum, or null if not found\r\n     */\r\n\r\n\r\n    function getChild(el, childNum, options) {\r\n        var currentChild = 0,\r\n            i = 0,\r\n            children = el.children;\r\n\r\n        while (i < children.length) {\r\n            if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {\r\n                if (currentChild === childNum) {\r\n                    return children[i];\r\n                }\r\n\r\n                currentChild++;\r\n            }\r\n\r\n            i++;\r\n        }\r\n\r\n        return null;\r\n    }\r\n    /**\r\n     * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\r\n     * @param  {HTMLElement} el       Parent element\r\n     * @param  {selector} selector    Any other elements that should be ignored\r\n     * @return {HTMLElement}          The last child, ignoring ghostEl\r\n     */\r\n\r\n\r\n    function lastChild(el, selector) {\r\n        var last = el.lastElementChild;\r\n\r\n        while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\r\n            last = last.previousElementSibling;\r\n        }\r\n\r\n        return last || null;\r\n    }\r\n    /**\r\n     * Returns the index of an element within its parent for a selected set of\r\n     * elements\r\n     * @param  {HTMLElement} el\r\n     * @param  {selector} selector\r\n     * @return {number}\r\n     */\r\n\r\n\r\n    function index(el, selector) {\r\n        var index = 0;\r\n\r\n        if (!el || !el.parentNode) {\r\n            return -1;\r\n        }\r\n        /* jshint boss:true */\r\n\r\n\r\n        while (el = el.previousElementSibling) {\r\n            if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return index;\r\n    }\r\n    /**\r\n     * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\r\n     * The value is returned in real pixels.\r\n     * @param  {HTMLElement} el\r\n     * @return {Array}             Offsets in the format of [left, top]\r\n     */\r\n\r\n\r\n    function getRelativeScrollOffset(el) {\r\n        var offsetLeft = 0,\r\n            offsetTop = 0,\r\n            winScroller = getWindowScrollingElement();\r\n\r\n        if (el) {\r\n            do {\r\n                var elMatrix = matrix(el),\r\n                    scaleX = elMatrix.a,\r\n                    scaleY = elMatrix.d;\r\n                offsetLeft += el.scrollLeft * scaleX;\r\n                offsetTop += el.scrollTop * scaleY;\r\n            } while (el !== winScroller && (el = el.parentNode));\r\n        }\r\n\r\n        return [offsetLeft, offsetTop];\r\n    }\r\n    /**\r\n     * Returns the index of the object within the given array\r\n     * @param  {Array} arr   Array that may or may not hold the object\r\n     * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\r\n     * @return {Number}      The index of the object in the array, or -1\r\n     */\r\n\r\n\r\n    function indexOfObject(arr, obj) {\r\n        for (var i in arr) {\r\n            if (!arr.hasOwnProperty(i)) continue;\r\n\r\n            for (var key in obj) {\r\n                if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    function getParentAutoScrollElement(el, includeSelf) {\r\n        // skip to window\r\n        if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\r\n        var elem = el;\r\n        var gotSelf = false;\r\n\r\n        do {\r\n            // we don't need to get elem css if it isn't even overflowing in the first place (performance)\r\n            if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\r\n                var elemCSS = css(elem);\r\n\r\n                if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\r\n                    if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\r\n                    if (gotSelf || includeSelf) return elem;\r\n                    gotSelf = true;\r\n                }\r\n            }\r\n            /* jshint boss:true */\r\n\r\n        } while (elem = elem.parentNode);\r\n\r\n        return getWindowScrollingElement();\r\n    }\r\n\r\n    function extend(dst, src) {\r\n        if (dst && src) {\r\n            for (var key in src) {\r\n                if (src.hasOwnProperty(key)) {\r\n                    dst[key] = src[key];\r\n                }\r\n            }\r\n        }\r\n\r\n        return dst;\r\n    }\r\n\r\n    function isRectEqual(rect1, rect2) {\r\n        return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\r\n    }\r\n\r\n    var _throttleTimeout;\r\n\r\n    function throttle(callback, ms) {\r\n        return function () {\r\n            if (!_throttleTimeout) {\r\n                var args = arguments,\r\n                    _this = this;\r\n\r\n                if (args.length === 1) {\r\n                    callback.call(_this, args[0]);\r\n                } else {\r\n                    callback.apply(_this, args);\r\n                }\r\n\r\n                _throttleTimeout = setTimeout(function () {\r\n                    _throttleTimeout = void 0;\r\n                }, ms);\r\n            }\r\n        };\r\n    }\r\n\r\n    function cancelThrottle() {\r\n        clearTimeout(_throttleTimeout);\r\n        _throttleTimeout = void 0;\r\n    }\r\n\r\n    function scrollBy(el, x, y) {\r\n        el.scrollLeft += x;\r\n        el.scrollTop += y;\r\n    }\r\n\r\n    function clone(el) {\r\n        var Polymer = window.Polymer;\r\n        var $ = window.jQuery || window.Zepto;\r\n\r\n        if (Polymer && Polymer.dom) {\r\n            return Polymer.dom(el).cloneNode(true);\r\n        } else if ($) {\r\n            return $(el).clone(true)[0];\r\n        } else {\r\n            return el.cloneNode(true);\r\n        }\r\n    }\r\n\r\n    function setRect(el, rect) {\r\n        css(el, 'position', 'absolute');\r\n        css(el, 'top', rect.top);\r\n        css(el, 'left', rect.left);\r\n        css(el, 'width', rect.width);\r\n        css(el, 'height', rect.height);\r\n    }\r\n\r\n    function unsetRect(el) {\r\n        css(el, 'position', '');\r\n        css(el, 'top', '');\r\n        css(el, 'left', '');\r\n        css(el, 'width', '');\r\n        css(el, 'height', '');\r\n    }\r\n\r\n    var expando = 'Sortable' + new Date().getTime();\r\n\r\n    function AnimationStateManager() {\r\n        var animationStates = [],\r\n            animationCallbackId;\r\n        return {\r\n            captureAnimationState: function captureAnimationState() {\r\n                animationStates = [];\r\n                if (!this.options.animation) return;\r\n                var children = [].slice.call(this.el.children);\r\n                children.forEach(function (child) {\r\n                    if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\r\n                    animationStates.push({\r\n                        target: child,\r\n                        rect: getRect(child)\r\n                    });\r\n\r\n                    var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation\r\n\r\n\r\n                    if (child.thisAnimationDuration) {\r\n                        var childMatrix = matrix(child, true);\r\n\r\n                        if (childMatrix) {\r\n                            fromRect.top -= childMatrix.f;\r\n                            fromRect.left -= childMatrix.e;\r\n                        }\r\n                    }\r\n\r\n                    child.fromRect = fromRect;\r\n                });\r\n            },\r\n            addAnimationState: function addAnimationState(state) {\r\n                animationStates.push(state);\r\n            },\r\n            removeAnimationState: function removeAnimationState(target) {\r\n                animationStates.splice(indexOfObject(animationStates, {\r\n                    target: target\r\n                }), 1);\r\n            },\r\n            animateAll: function animateAll(callback) {\r\n                var _this = this;\r\n\r\n                if (!this.options.animation) {\r\n                    clearTimeout(animationCallbackId);\r\n                    if (typeof callback === 'function') callback();\r\n                    return;\r\n                }\r\n\r\n                var animating = false,\r\n                    animationTime = 0;\r\n                animationStates.forEach(function (state) {\r\n                    var time = 0,\r\n                        target = state.target,\r\n                        fromRect = target.fromRect,\r\n                        toRect = getRect(target),\r\n                        prevFromRect = target.prevFromRect,\r\n                        prevToRect = target.prevToRect,\r\n                        animatingRect = state.rect,\r\n                        targetMatrix = matrix(target, true);\r\n\r\n                    if (targetMatrix) {\r\n                        // Compensate for current animation\r\n                        toRect.top -= targetMatrix.f;\r\n                        toRect.left -= targetMatrix.e;\r\n                    }\r\n\r\n                    target.toRect = toRect;\r\n\r\n                    if (target.thisAnimationDuration) {\r\n                        // Could also check if animatingRect is between fromRect and toRect\r\n                        if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect\r\n                            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\r\n                            // If returning to same place as started from animation and on same axis\r\n                            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\r\n                        }\r\n                    } // if fromRect != toRect: animate\r\n\r\n\r\n                    if (!isRectEqual(toRect, fromRect)) {\r\n                        target.prevFromRect = fromRect;\r\n                        target.prevToRect = toRect;\r\n\r\n                        if (!time) {\r\n                            time = _this.options.animation;\r\n                        }\r\n\r\n                        _this.animate(target, animatingRect, toRect, time);\r\n                    }\r\n\r\n                    if (time) {\r\n                        animating = true;\r\n                        animationTime = Math.max(animationTime, time);\r\n                        clearTimeout(target.animationResetTimer);\r\n                        target.animationResetTimer = setTimeout(function () {\r\n                            target.animationTime = 0;\r\n                            target.prevFromRect = null;\r\n                            target.fromRect = null;\r\n                            target.prevToRect = null;\r\n                            target.thisAnimationDuration = null;\r\n                        }, time);\r\n                        target.thisAnimationDuration = time;\r\n                    }\r\n                });\r\n                clearTimeout(animationCallbackId);\r\n\r\n                if (!animating) {\r\n                    if (typeof callback === 'function') callback();\r\n                } else {\r\n                    animationCallbackId = setTimeout(function () {\r\n                        if (typeof callback === 'function') callback();\r\n                    }, animationTime);\r\n                }\r\n\r\n                animationStates = [];\r\n            },\r\n            animate: function animate(target, currentRect, toRect, duration) {\r\n                if (duration) {\r\n                    css(target, 'transition', '');\r\n                    css(target, 'transform', '');\r\n                    var elMatrix = matrix(this.el),\r\n                        scaleX = elMatrix && elMatrix.a,\r\n                        scaleY = elMatrix && elMatrix.d,\r\n                        translateX = (currentRect.left - toRect.left) / (scaleX || 1),\r\n                        translateY = (currentRect.top - toRect.top) / (scaleY || 1);\r\n                    target.animatingX = !!translateX;\r\n                    target.animatingY = !!translateY;\r\n                    css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\r\n                    repaint(target); // repaint\r\n\r\n                    css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\r\n                    css(target, 'transform', 'translate3d(0,0,0)');\r\n                    typeof target.animated === 'number' && clearTimeout(target.animated);\r\n                    target.animated = setTimeout(function () {\r\n                        css(target, 'transition', '');\r\n                        css(target, 'transform', '');\r\n                        target.animated = false;\r\n                        target.animatingX = false;\r\n                        target.animatingY = false;\r\n                    }, duration);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    function repaint(target) {\r\n        return target.offsetWidth;\r\n    }\r\n\r\n    function calculateRealTime(animatingRect, fromRect, toRect, options) {\r\n        return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\r\n    }\r\n\r\n    var plugins = [];\r\n    var defaults = {\r\n        initializeByDefault: true\r\n    };\r\n    var PluginManager = {\r\n        mount: function mount(plugin) {\r\n            // Set default static properties\r\n            for (var option in defaults) {\r\n                if (defaults.hasOwnProperty(option) && !(option in plugin)) {\r\n                    plugin[option] = defaults[option];\r\n                }\r\n            }\r\n\r\n            plugins.push(plugin);\r\n        },\r\n        pluginEvent: function pluginEvent(eventName, sortable, evt) {\r\n            var _this = this;\r\n\r\n            this.eventCanceled = false;\r\n\r\n            evt.cancel = function () {\r\n                _this.eventCanceled = true;\r\n            };\r\n\r\n            var eventNameGlobal = eventName + 'Global';\r\n            plugins.forEach(function (plugin) {\r\n                if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable\r\n\r\n                if (sortable[plugin.pluginName][eventNameGlobal]) {\r\n                    sortable[plugin.pluginName][eventNameGlobal](_objectSpread({\r\n                        sortable: sortable\r\n                    }, evt));\r\n                } // Only fire plugin event if plugin is enabled in this sortable,\r\n                // and plugin has event defined\r\n\r\n\r\n                if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\r\n                    sortable[plugin.pluginName][eventName](_objectSpread({\r\n                        sortable: sortable\r\n                    }, evt));\r\n                }\r\n            });\r\n        },\r\n        initializePlugins: function initializePlugins(sortable, el, defaults, options) {\r\n            plugins.forEach(function (plugin) {\r\n                var pluginName = plugin.pluginName;\r\n                if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\r\n                var initialized = new plugin(sortable, el, sortable.options);\r\n                initialized.sortable = sortable;\r\n                initialized.options = sortable.options;\r\n                sortable[pluginName] = initialized; // Add default options from plugin\r\n\r\n                _extends(defaults, initialized.defaults);\r\n            });\r\n\r\n            for (var option in sortable.options) {\r\n                if (!sortable.options.hasOwnProperty(option)) continue;\r\n                var modified = this.modifyOption(sortable, option, sortable.options[option]);\r\n\r\n                if (typeof modified !== 'undefined') {\r\n                    sortable.options[option] = modified;\r\n                }\r\n            }\r\n        },\r\n        getEventProperties: function getEventProperties(name, sortable) {\r\n            var eventProperties = {};\r\n            plugins.forEach(function (plugin) {\r\n                if (typeof plugin.eventProperties !== 'function') return;\r\n\r\n                _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\r\n            });\r\n            return eventProperties;\r\n        },\r\n        modifyOption: function modifyOption(sortable, name, value) {\r\n            var modifiedValue;\r\n            plugins.forEach(function (plugin) {\r\n                // Plugin must exist on the Sortable\r\n                if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\r\n\r\n                if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\r\n                    modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\r\n                }\r\n            });\r\n            return modifiedValue;\r\n        }\r\n    };\r\n\r\n    function dispatchEvent(_ref) {\r\n        var sortable = _ref.sortable,\r\n            rootEl = _ref.rootEl,\r\n            name = _ref.name,\r\n            targetEl = _ref.targetEl,\r\n            cloneEl = _ref.cloneEl,\r\n            toEl = _ref.toEl,\r\n            fromEl = _ref.fromEl,\r\n            oldIndex = _ref.oldIndex,\r\n            newIndex = _ref.newIndex,\r\n            oldDraggableIndex = _ref.oldDraggableIndex,\r\n            newDraggableIndex = _ref.newDraggableIndex,\r\n            originalEvent = _ref.originalEvent,\r\n            putSortable = _ref.putSortable,\r\n            extraEventProperties = _ref.extraEventProperties;\r\n        sortable = sortable || rootEl && rootEl[expando];\r\n        if (!sortable) return;\r\n        var evt,\r\n            options = sortable.options,\r\n            onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature\r\n\r\n        if (window.CustomEvent && !IE11OrLess && !Edge) {\r\n            evt = new CustomEvent(name, {\r\n                bubbles: true,\r\n                cancelable: true\r\n            });\r\n        } else {\r\n            evt = document.createEvent('Event');\r\n            evt.initEvent(name, true, true);\r\n        }\r\n\r\n        evt.to = toEl || rootEl;\r\n        evt.from = fromEl || rootEl;\r\n        evt.item = targetEl || rootEl;\r\n        evt.clone = cloneEl;\r\n        evt.oldIndex = oldIndex;\r\n        evt.newIndex = newIndex;\r\n        evt.oldDraggableIndex = oldDraggableIndex;\r\n        evt.newDraggableIndex = newDraggableIndex;\r\n        evt.originalEvent = originalEvent;\r\n        evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\r\n\r\n        var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));\r\n\r\n        for (var option in allEventProperties) {\r\n            evt[option] = allEventProperties[option];\r\n        }\r\n\r\n        if (rootEl) {\r\n            rootEl.dispatchEvent(evt);\r\n        }\r\n\r\n        if (options[onName]) {\r\n            options[onName].call(sortable, evt);\r\n        }\r\n    }\r\n\r\n    var pluginEvent = function pluginEvent(eventName, sortable) {\r\n        var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\r\n            originalEvent = _ref.evt,\r\n            data = _objectWithoutProperties(_ref, [\"evt\"]);\r\n\r\n        PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({\r\n            dragEl: dragEl,\r\n            parentEl: parentEl,\r\n            ghostEl: ghostEl,\r\n            rootEl: rootEl,\r\n            nextEl: nextEl,\r\n            lastDownEl: lastDownEl,\r\n            cloneEl: cloneEl,\r\n            cloneHidden: cloneHidden,\r\n            dragStarted: moved,\r\n            putSortable: putSortable,\r\n            activeSortable: Sortable.active,\r\n            originalEvent: originalEvent,\r\n            oldIndex: oldIndex,\r\n            oldDraggableIndex: oldDraggableIndex,\r\n            newIndex: newIndex,\r\n            newDraggableIndex: newDraggableIndex,\r\n            hideGhostForTarget: _hideGhostForTarget,\r\n            unhideGhostForTarget: _unhideGhostForTarget,\r\n            cloneNowHidden: function cloneNowHidden() {\r\n                cloneHidden = true;\r\n            },\r\n            cloneNowShown: function cloneNowShown() {\r\n                cloneHidden = false;\r\n            },\r\n            dispatchSortableEvent: function dispatchSortableEvent(name) {\r\n                _dispatchEvent({\r\n                    sortable: sortable,\r\n                    name: name,\r\n                    originalEvent: originalEvent\r\n                });\r\n            }\r\n        }, data));\r\n    };\r\n\r\n    function _dispatchEvent(info) {\r\n        dispatchEvent(_objectSpread({\r\n            putSortable: putSortable,\r\n            cloneEl: cloneEl,\r\n            targetEl: dragEl,\r\n            rootEl: rootEl,\r\n            oldIndex: oldIndex,\r\n            oldDraggableIndex: oldDraggableIndex,\r\n            newIndex: newIndex,\r\n            newDraggableIndex: newDraggableIndex\r\n        }, info));\r\n    }\r\n\r\n    var dragEl,\r\n        parentEl,\r\n        ghostEl,\r\n        rootEl,\r\n        nextEl,\r\n        lastDownEl,\r\n        cloneEl,\r\n        cloneHidden,\r\n        oldIndex,\r\n        newIndex,\r\n        oldDraggableIndex,\r\n        newDraggableIndex,\r\n        activeGroup,\r\n        putSortable,\r\n        awaitingDragStarted = false,\r\n        ignoreNextClick = false,\r\n        sortables = [],\r\n        tapEvt,\r\n        touchEvt,\r\n        lastDx,\r\n        lastDy,\r\n        tapDistanceLeft,\r\n        tapDistanceTop,\r\n        moved,\r\n        lastTarget,\r\n        lastDirection,\r\n        pastFirstInvertThresh = false,\r\n        isCircumstantialInvert = false,\r\n        targetMoveDistance,\r\n        // For positioning ghost absolutely\r\n        ghostRelativeParent,\r\n        ghostRelativeParentInitialScroll = [],\r\n        // (left, top)\r\n        _silent = false,\r\n        savedInputChecked = [];\r\n    /** @const */\r\n\r\n    var documentExists = typeof document !== 'undefined',\r\n        PositionGhostAbsolutely = IOS,\r\n        CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\r\n        // This will not pass for IE9, because IE9 DnD only works on anchors\r\n        supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\r\n        supportCssPointerEvents = function () {\r\n            if (!documentExists) return; // false when <= IE11\r\n\r\n            if (IE11OrLess) {\r\n                return false;\r\n            }\r\n\r\n            var el = document.createElement('x');\r\n            el.style.cssText = 'pointer-events:auto';\r\n            return el.style.pointerEvents === 'auto';\r\n        }(),\r\n        _detectDirection = function _detectDirection(el, options) {\r\n            var elCSS = css(el),\r\n                elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\r\n                child1 = getChild(el, 0, options),\r\n                child2 = getChild(el, 1, options),\r\n                firstChildCSS = child1 && css(child1),\r\n                secondChildCSS = child2 && css(child2),\r\n                firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\r\n                secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\r\n\r\n            if (elCSS.display === 'flex') {\r\n                return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\r\n            }\r\n\r\n            if (elCSS.display === 'grid') {\r\n                return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\r\n            }\r\n\r\n            if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\r\n                var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\r\n                return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\r\n            }\r\n\r\n            return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\r\n        },\r\n        _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\r\n            var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\r\n                dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\r\n                dragElOppLength = vertical ? dragRect.width : dragRect.height,\r\n                targetS1Opp = vertical ? targetRect.left : targetRect.top,\r\n                targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\r\n                targetOppLength = vertical ? targetRect.width : targetRect.height;\r\n            return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\r\n        },\r\n\r\n        /**\r\n         * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\r\n         * @param  {Number} x      X position\r\n         * @param  {Number} y      Y position\r\n         * @return {HTMLElement}   Element of the first found nearest Sortable\r\n         */\r\n        _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\r\n            var ret;\r\n            sortables.some(function (sortable) {\r\n                if (lastChild(sortable)) return;\r\n                var rect = getRect(sortable),\r\n                    threshold = sortable[expando].options.emptyInsertThreshold,\r\n                    insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\r\n                    insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\r\n\r\n                if (threshold && insideHorizontally && insideVertically) {\r\n                    return ret = sortable;\r\n                }\r\n            });\r\n            return ret;\r\n        },\r\n        _prepareGroup = function _prepareGroup(options) {\r\n            function toFn(value, pull) {\r\n                return function (to, from, dragEl, evt) {\r\n                    var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\r\n\r\n                    if (value == null && (pull || sameGroup)) {\r\n                        // Default pull value\r\n                        // Default pull and put value if same group\r\n                        return true;\r\n                    } else if (value == null || value === false) {\r\n                        return false;\r\n                    } else if (pull && value === 'clone') {\r\n                        return value;\r\n                    } else if (typeof value === 'function') {\r\n                        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\r\n                    } else {\r\n                        var otherGroup = (pull ? to : from).options.group.name;\r\n                        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\r\n                    }\r\n                };\r\n            }\r\n\r\n            var group = {};\r\n            var originalGroup = options.group;\r\n\r\n            if (!originalGroup || _typeof(originalGroup) != 'object') {\r\n                originalGroup = {\r\n                    name: originalGroup\r\n                };\r\n            }\r\n\r\n            group.name = originalGroup.name;\r\n            group.checkPull = toFn(originalGroup.pull, true);\r\n            group.checkPut = toFn(originalGroup.put);\r\n            group.revertClone = originalGroup.revertClone;\r\n            options.group = group;\r\n        },\r\n        _hideGhostForTarget = function _hideGhostForTarget() {\r\n            if (!supportCssPointerEvents && ghostEl) {\r\n                css(ghostEl, 'display', 'none');\r\n            }\r\n        },\r\n        _unhideGhostForTarget = function _unhideGhostForTarget() {\r\n            if (!supportCssPointerEvents && ghostEl) {\r\n                css(ghostEl, 'display', '');\r\n            }\r\n        }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position\r\n\r\n\r\n    if (documentExists) {\r\n        document.addEventListener('click', function (evt) {\r\n            if (ignoreNextClick) {\r\n                evt.preventDefault();\r\n                evt.stopPropagation && evt.stopPropagation();\r\n                evt.stopImmediatePropagation && evt.stopImmediatePropagation();\r\n                ignoreNextClick = false;\r\n                return false;\r\n            }\r\n        }, true);\r\n    }\r\n\r\n    var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\r\n        if (dragEl) {\r\n            evt = evt.touches ? evt.touches[0] : evt;\r\n\r\n            var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\r\n\r\n            if (nearest) {\r\n                // Create imitation event\r\n                var event = {};\r\n\r\n                for (var i in evt) {\r\n                    if (evt.hasOwnProperty(i)) {\r\n                        event[i] = evt[i];\r\n                    }\r\n                }\r\n\r\n                event.target = event.rootEl = nearest;\r\n                event.preventDefault = void 0;\r\n                event.stopPropagation = void 0;\r\n\r\n                nearest[expando]._onDragOver(event);\r\n            }\r\n        }\r\n    };\r\n\r\n    var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\r\n        if (dragEl) {\r\n            dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\r\n        }\r\n    };\r\n    /**\r\n     * @class  Sortable\r\n     * @param  {HTMLElement}  el\r\n     * @param  {Object}       [options]\r\n     */\r\n\r\n\r\n    function Sortable(el, options) {\r\n        if (!(el && el.nodeType && el.nodeType === 1)) {\r\n            throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\r\n        }\r\n\r\n        this.el = el; // root element\r\n\r\n        this.options = options = _extends({}, options); // Export instance\r\n\r\n        el[expando] = this;\r\n        var defaults = {\r\n            group: null,\r\n            sort: true,\r\n            disabled: false,\r\n            store: null,\r\n            handle: null,\r\n            draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\r\n            swapThreshold: 1,\r\n            // percentage; 0 <= x <= 1\r\n            invertSwap: false,\r\n            // invert always\r\n            invertedSwapThreshold: null,\r\n            // will be set to same as swapThreshold if default\r\n            removeCloneOnHide: true,\r\n            direction: function direction() {\r\n                return _detectDirection(el, this.options);\r\n            },\r\n            ghostClass: 'sortable-ghost',\r\n            chosenClass: 'sortable-chosen',\r\n            dragClass: 'sortable-drag',\r\n            ignore: 'a, img',\r\n            filter: null,\r\n            preventOnFilter: true,\r\n            animation: 0,\r\n            easing: null,\r\n            setData: function setData(dataTransfer, dragEl) {\r\n                dataTransfer.setData('Text', dragEl.textContent);\r\n            },\r\n            dropBubble: false,\r\n            dragoverBubble: false,\r\n            dataIdAttr: 'data-id',\r\n            delay: 0,\r\n            delayOnTouchOnly: false,\r\n            touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\r\n            forceFallback: false,\r\n            fallbackClass: 'sortable-fallback',\r\n            fallbackOnBody: false,\r\n            fallbackTolerance: 0,\r\n            fallbackOffset: {\r\n                x: 0,\r\n                y: 0\r\n            },\r\n            supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window,\r\n            emptyInsertThreshold: 5\r\n        };\r\n        PluginManager.initializePlugins(this, el, defaults); // Set default options\r\n\r\n        for (var name in defaults) {\r\n            !(name in options) && (options[name] = defaults[name]);\r\n        }\r\n\r\n        _prepareGroup(options); // Bind all private methods\r\n\r\n\r\n        for (var fn in this) {\r\n            if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\r\n                this[fn] = this[fn].bind(this);\r\n            }\r\n        } // Setup drag mode\r\n\r\n\r\n        this.nativeDraggable = options.forceFallback ? false : supportDraggable;\r\n\r\n        if (this.nativeDraggable) {\r\n            // Touch start threshold cannot be greater than the native dragstart threshold\r\n            this.options.touchStartThreshold = 1;\r\n        } // Bind events\r\n\r\n\r\n        if (options.supportPointer) {\r\n            on(el, 'pointerdown', this._onTapStart);\r\n        } else {\r\n            on(el, 'mousedown', this._onTapStart);\r\n            on(el, 'touchstart', this._onTapStart);\r\n        }\r\n\r\n        if (this.nativeDraggable) {\r\n            on(el, 'dragover', this);\r\n            on(el, 'dragenter', this);\r\n        }\r\n\r\n        sortables.push(this.el); // Restore sorting\r\n\r\n        options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager\r\n\r\n        _extends(this, AnimationStateManager());\r\n    }\r\n\r\n    Sortable.prototype =\r\n        /** @lends Sortable.prototype */\r\n        {\r\n            constructor: Sortable,\r\n            _isOutsideThisEl: function _isOutsideThisEl(target) {\r\n                if (!this.el.contains(target) && target !== this.el) {\r\n                    lastTarget = null;\r\n                }\r\n            },\r\n            _getDirection: function _getDirection(evt, target) {\r\n                return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\r\n            },\r\n            _onTapStart: function _onTapStart(\r\n                /** Event|TouchEvent */\r\n                evt) {\r\n                if (!evt.cancelable) return;\r\n\r\n                var _this = this,\r\n                    el = this.el,\r\n                    options = this.options,\r\n                    preventOnFilter = options.preventOnFilter,\r\n                    type = evt.type,\r\n                    touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\r\n                    target = (touch || evt).target,\r\n                    originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\r\n                    filter = options.filter;\r\n\r\n                _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\r\n\r\n\r\n                if (dragEl) {\r\n                    return;\r\n                }\r\n\r\n                if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\r\n                    return; // only left button and enabled\r\n                } // cancel dnd if original target is content editable\r\n\r\n\r\n                if (originalTarget.isContentEditable) {\r\n                    return;\r\n                }\r\n\r\n                target = closest(target, options.draggable, el, false);\r\n\r\n                if (target && target.animated) {\r\n                    return;\r\n                }\r\n\r\n                if (lastDownEl === target) {\r\n                    // Ignoring duplicate `down`\r\n                    return;\r\n                } // Get the index of the dragged element within its parent\r\n\r\n\r\n                oldIndex = index(target);\r\n                oldDraggableIndex = index(target, options.draggable); // Check filter\r\n\r\n                if (typeof filter === 'function') {\r\n                    if (filter.call(this, evt, target, this)) {\r\n                        _dispatchEvent({\r\n                            sortable: _this,\r\n                            rootEl: originalTarget,\r\n                            name: 'filter',\r\n                            targetEl: target,\r\n                            toEl: el,\r\n                            fromEl: el\r\n                        });\r\n\r\n                        pluginEvent('filter', _this, {\r\n                            evt: evt\r\n                        });\r\n                        preventOnFilter && evt.cancelable && evt.preventDefault();\r\n                        return; // cancel dnd\r\n                    }\r\n                } else if (filter) {\r\n                    filter = filter.split(',').some(function (criteria) {\r\n                        criteria = closest(originalTarget, criteria.trim(), el, false);\r\n\r\n                        if (criteria) {\r\n                            _dispatchEvent({\r\n                                sortable: _this,\r\n                                rootEl: criteria,\r\n                                name: 'filter',\r\n                                targetEl: target,\r\n                                fromEl: el,\r\n                                toEl: el\r\n                            });\r\n\r\n                            pluginEvent('filter', _this, {\r\n                                evt: evt\r\n                            });\r\n                            return true;\r\n                        }\r\n                    });\r\n\r\n                    if (filter) {\r\n                        preventOnFilter && evt.cancelable && evt.preventDefault();\r\n                        return; // cancel dnd\r\n                    }\r\n                }\r\n\r\n                if (options.handle && !closest(originalTarget, options.handle, el, false)) {\r\n                    return;\r\n                } // Prepare `dragstart`\r\n\r\n\r\n                this._prepareDragStart(evt, touch, target);\r\n            },\r\n            _prepareDragStart: function _prepareDragStart(\r\n                /** Event */\r\n                evt,\r\n                /** Touch */\r\n                touch,\r\n                /** HTMLElement */\r\n                target) {\r\n                var _this = this,\r\n                    el = _this.el,\r\n                    options = _this.options,\r\n                    ownerDocument = el.ownerDocument,\r\n                    dragStartFn;\r\n\r\n                if (target && !dragEl && target.parentNode === el) {\r\n                    var dragRect = getRect(target);\r\n                    rootEl = el;\r\n                    dragEl = target;\r\n                    parentEl = dragEl.parentNode;\r\n                    nextEl = dragEl.nextSibling;\r\n                    lastDownEl = target;\r\n                    activeGroup = options.group;\r\n                    Sortable.dragged = dragEl;\r\n                    tapEvt = {\r\n                        target: dragEl,\r\n                        clientX: (touch || evt).clientX,\r\n                        clientY: (touch || evt).clientY\r\n                    };\r\n                    tapDistanceLeft = tapEvt.clientX - dragRect.left;\r\n                    tapDistanceTop = tapEvt.clientY - dragRect.top;\r\n                    this._lastX = (touch || evt).clientX;\r\n                    this._lastY = (touch || evt).clientY;\r\n                    dragEl.style['will-change'] = 'all';\r\n\r\n                    dragStartFn = function dragStartFn() {\r\n                        pluginEvent('delayEnded', _this, {\r\n                            evt: evt\r\n                        });\r\n\r\n                        if (Sortable.eventCanceled) {\r\n                            _this._onDrop();\r\n\r\n                            return;\r\n                        } // Delayed drag has been triggered\r\n                        // we can re-enable the events: touchmove/mousemove\r\n\r\n\r\n                        _this._disableDelayedDragEvents();\r\n\r\n                        if (!FireFox && _this.nativeDraggable) {\r\n                            dragEl.draggable = true;\r\n                        } // Bind the events: dragstart/dragend\r\n\r\n\r\n                        _this._triggerDragStart(evt, touch); // Drag start event\r\n\r\n\r\n                        _dispatchEvent({\r\n                            sortable: _this,\r\n                            name: 'choose',\r\n                            originalEvent: evt\r\n                        }); // Chosen item\r\n\r\n\r\n                        toggleClass(dragEl, options.chosenClass, true);\r\n                    }; // Disable \"draggable\"\r\n\r\n\r\n                    options.ignore.split(',').forEach(function (criteria) {\r\n                        find(dragEl, criteria.trim(), _disableDraggable);\r\n                    });\r\n                    on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\r\n                    on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\r\n                    on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\r\n                    on(ownerDocument, 'mouseup', _this._onDrop);\r\n                    on(ownerDocument, 'touchend', _this._onDrop);\r\n                    on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)\r\n\r\n                    if (FireFox && this.nativeDraggable) {\r\n                        this.options.touchStartThreshold = 4;\r\n                        dragEl.draggable = true;\r\n                    }\r\n\r\n                    pluginEvent('delayStart', this, {\r\n                        evt: evt\r\n                    }); // Delay is impossible for native DnD in Edge or IE\r\n\r\n                    if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\r\n                        if (Sortable.eventCanceled) {\r\n                            this._onDrop();\r\n\r\n                            return;\r\n                        } // If the user moves the pointer or let go the click or touch\r\n                        // before the delay has been reached:\r\n                        // disable the delayed drag\r\n\r\n\r\n                        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\r\n                        on(ownerDocument, 'touchend', _this._disableDelayedDrag);\r\n                        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\r\n                        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\r\n                        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\r\n                        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\r\n                        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\r\n                    } else {\r\n                        dragStartFn();\r\n                    }\r\n                }\r\n            },\r\n            _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(\r\n                /** TouchEvent|PointerEvent **/\r\n                e) {\r\n                var touch = e.touches ? e.touches[0] : e;\r\n\r\n                if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\r\n                    this._disableDelayedDrag();\r\n                }\r\n            },\r\n            _disableDelayedDrag: function _disableDelayedDrag() {\r\n                dragEl && _disableDraggable(dragEl);\r\n                clearTimeout(this._dragStartTimer);\r\n\r\n                this._disableDelayedDragEvents();\r\n            },\r\n            _disableDelayedDragEvents: function _disableDelayedDragEvents() {\r\n                var ownerDocument = this.el.ownerDocument;\r\n                off(ownerDocument, 'mouseup', this._disableDelayedDrag);\r\n                off(ownerDocument, 'touchend', this._disableDelayedDrag);\r\n                off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\r\n                off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\r\n                off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\r\n                off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\r\n            },\r\n            _triggerDragStart: function _triggerDragStart(\r\n                /** Event */\r\n                evt,\r\n                /** Touch */\r\n                touch) {\r\n                touch = touch || evt.pointerType == 'touch' && evt;\r\n\r\n                if (!this.nativeDraggable || touch) {\r\n                    if (this.options.supportPointer) {\r\n                        on(document, 'pointermove', this._onTouchMove);\r\n                    } else if (touch) {\r\n                        on(document, 'touchmove', this._onTouchMove);\r\n                    } else {\r\n                        on(document, 'mousemove', this._onTouchMove);\r\n                    }\r\n                } else {\r\n                    on(dragEl, 'dragend', this);\r\n                    on(rootEl, 'dragstart', this._onDragStart);\r\n                }\r\n\r\n                try {\r\n                    if (document.selection) {\r\n                        // Timeout neccessary for IE9\r\n                        _nextTick(function () {\r\n                            document.selection.empty();\r\n                        });\r\n                    } else {\r\n                        window.getSelection().removeAllRanges();\r\n                    }\r\n                } catch (err) {}\r\n            },\r\n            _dragStarted: function _dragStarted(fallback, evt) {\r\n\r\n                awaitingDragStarted = false;\r\n\r\n                if (rootEl && dragEl) {\r\n                    pluginEvent('dragStarted', this, {\r\n                        evt: evt\r\n                    });\r\n\r\n                    if (this.nativeDraggable) {\r\n                        on(document, 'dragover', _checkOutsideTargetEl);\r\n                    }\r\n\r\n                    var options = this.options; // Apply effect\r\n\r\n                    !fallback && toggleClass(dragEl, options.dragClass, false);\r\n                    toggleClass(dragEl, options.ghostClass, true);\r\n                    Sortable.active = this;\r\n                    fallback && this._appendGhost(); // Drag start event\r\n\r\n                    _dispatchEvent({\r\n                        sortable: this,\r\n                        name: 'start',\r\n                        originalEvent: evt\r\n                    });\r\n                } else {\r\n                    this._nulling();\r\n                }\r\n            },\r\n            _emulateDragOver: function _emulateDragOver() {\r\n                if (touchEvt) {\r\n                    this._lastX = touchEvt.clientX;\r\n                    this._lastY = touchEvt.clientY;\r\n\r\n                    _hideGhostForTarget();\r\n\r\n                    var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\r\n                    var parent = target;\r\n\r\n                    while (target && target.shadowRoot) {\r\n                        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\r\n                        if (target === parent) break;\r\n                        parent = target;\r\n                    }\r\n\r\n                    dragEl.parentNode[expando]._isOutsideThisEl(target);\r\n\r\n                    if (parent) {\r\n                        do {\r\n                            if (parent[expando]) {\r\n                                var inserted = void 0;\r\n                                inserted = parent[expando]._onDragOver({\r\n                                    clientX: touchEvt.clientX,\r\n                                    clientY: touchEvt.clientY,\r\n                                    target: target,\r\n                                    rootEl: parent\r\n                                });\r\n\r\n                                if (inserted && !this.options.dragoverBubble) {\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            target = parent; // store last element\r\n                        }\r\n                            /* jshint boss:true */\r\n                        while (parent = parent.parentNode);\r\n                    }\r\n\r\n                    _unhideGhostForTarget();\r\n                }\r\n            },\r\n            _onTouchMove: function _onTouchMove(\r\n                /**TouchEvent*/\r\n                evt) {\r\n                if (tapEvt) {\r\n                    var options = this.options,\r\n                        fallbackTolerance = options.fallbackTolerance,\r\n                        fallbackOffset = options.fallbackOffset,\r\n                        touch = evt.touches ? evt.touches[0] : evt,\r\n                        ghostMatrix = ghostEl && matrix(ghostEl, true),\r\n                        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\r\n                        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\r\n                        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\r\n                        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\r\n                        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging\r\n\r\n                    if (!Sortable.active && !awaitingDragStarted) {\r\n                        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\r\n                            return;\r\n                        }\r\n\r\n                        this._onDragStart(evt, true);\r\n                    }\r\n\r\n                    if (ghostEl) {\r\n                        if (ghostMatrix) {\r\n                            ghostMatrix.e += dx - (lastDx || 0);\r\n                            ghostMatrix.f += dy - (lastDy || 0);\r\n                        } else {\r\n                            ghostMatrix = {\r\n                                a: 1,\r\n                                b: 0,\r\n                                c: 0,\r\n                                d: 1,\r\n                                e: dx,\r\n                                f: dy\r\n                            };\r\n                        }\r\n\r\n                        var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\r\n                        css(ghostEl, 'webkitTransform', cssMatrix);\r\n                        css(ghostEl, 'mozTransform', cssMatrix);\r\n                        css(ghostEl, 'msTransform', cssMatrix);\r\n                        css(ghostEl, 'transform', cssMatrix);\r\n                        lastDx = dx;\r\n                        lastDy = dy;\r\n                        touchEvt = touch;\r\n                    }\r\n\r\n                    evt.cancelable && evt.preventDefault();\r\n                }\r\n            },\r\n            _appendGhost: function _appendGhost() {\r\n                // Bug if using scale(): https://stackoverflow.com/questions/2637058\r\n                // Not being adjusted for\r\n                if (!ghostEl) {\r\n                    var container = this.options.fallbackOnBody ? document.body : rootEl,\r\n                        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\r\n                        options = this.options; // Position absolutely\r\n\r\n                    if (PositionGhostAbsolutely) {\r\n                        // Get relatively positioned parent\r\n                        ghostRelativeParent = container;\r\n\r\n                        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\r\n                            ghostRelativeParent = ghostRelativeParent.parentNode;\r\n                        }\r\n\r\n                        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\r\n                            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\r\n                            rect.top += ghostRelativeParent.scrollTop;\r\n                            rect.left += ghostRelativeParent.scrollLeft;\r\n                        } else {\r\n                            ghostRelativeParent = getWindowScrollingElement();\r\n                        }\r\n\r\n                        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\r\n                    }\r\n\r\n                    ghostEl = dragEl.cloneNode(true);\r\n                    toggleClass(ghostEl, options.ghostClass, false);\r\n                    toggleClass(ghostEl, options.fallbackClass, true);\r\n                    toggleClass(ghostEl, options.dragClass, true);\r\n                    css(ghostEl, 'transition', '');\r\n                    css(ghostEl, 'transform', '');\r\n                    css(ghostEl, 'box-sizing', 'border-box');\r\n                    css(ghostEl, 'margin', 0);\r\n                    css(ghostEl, 'top', rect.top);\r\n                    css(ghostEl, 'left', rect.left);\r\n                    css(ghostEl, 'width', rect.width);\r\n                    css(ghostEl, 'height', rect.height);\r\n                    css(ghostEl, 'opacity', '0.8');\r\n                    css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\r\n                    css(ghostEl, 'zIndex', '100000');\r\n                    css(ghostEl, 'pointerEvents', 'none');\r\n                    Sortable.ghost = ghostEl;\r\n                    container.appendChild(ghostEl); // Set transform-origin\r\n\r\n                    css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\r\n                }\r\n            },\r\n            _onDragStart: function _onDragStart(\r\n                /**Event*/\r\n                evt,\r\n                /**boolean*/\r\n                fallback) {\r\n                var _this = this;\r\n\r\n                var dataTransfer = evt.dataTransfer;\r\n                var options = _this.options;\r\n                pluginEvent('dragStart', this, {\r\n                    evt: evt\r\n                });\r\n\r\n                if (Sortable.eventCanceled) {\r\n                    this._onDrop();\r\n\r\n                    return;\r\n                }\r\n\r\n                pluginEvent('setupClone', this);\r\n\r\n                if (!Sortable.eventCanceled) {\r\n                    cloneEl = clone(dragEl);\r\n                    cloneEl.draggable = false;\r\n                    cloneEl.style['will-change'] = '';\r\n\r\n                    this._hideClone();\r\n\r\n                    toggleClass(cloneEl, this.options.chosenClass, false);\r\n                    Sortable.clone = cloneEl;\r\n                } // #1143: IFrame support workaround\r\n\r\n\r\n                _this.cloneId = _nextTick(function () {\r\n                    pluginEvent('clone', _this);\r\n                    if (Sortable.eventCanceled) return;\r\n\r\n                    if (!_this.options.removeCloneOnHide) {\r\n                        rootEl.insertBefore(cloneEl, dragEl);\r\n                    }\r\n\r\n                    _this._hideClone();\r\n\r\n                    _dispatchEvent({\r\n                        sortable: _this,\r\n                        name: 'clone'\r\n                    });\r\n                });\r\n                !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events\r\n\r\n                if (fallback) {\r\n                    ignoreNextClick = true;\r\n                    _this._loopId = setInterval(_this._emulateDragOver, 50);\r\n                } else {\r\n                    // Undo what was set in _prepareDragStart before drag started\r\n                    off(document, 'mouseup', _this._onDrop);\r\n                    off(document, 'touchend', _this._onDrop);\r\n                    off(document, 'touchcancel', _this._onDrop);\r\n\r\n                    if (dataTransfer) {\r\n                        dataTransfer.effectAllowed = 'move';\r\n                        options.setData && options.setData.call(_this, dataTransfer, dragEl);\r\n                    }\r\n\r\n                    on(document, 'drop', _this); // #1276 fix:\r\n\r\n                    css(dragEl, 'transform', 'translateZ(0)');\r\n                }\r\n\r\n                awaitingDragStarted = true;\r\n                _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\r\n                on(document, 'selectstart', _this);\r\n                moved = true;\r\n\r\n                if (Safari) {\r\n                    css(document.body, 'user-select', 'none');\r\n                }\r\n            },\r\n            // Returns true - if no further action is needed (either inserted or another condition)\r\n            _onDragOver: function _onDragOver(\r\n                /**Event*/\r\n                evt) {\r\n                var el = this.el,\r\n                    target = evt.target,\r\n                    dragRect,\r\n                    targetRect,\r\n                    revert,\r\n                    options = this.options,\r\n                    group = options.group,\r\n                    activeSortable = Sortable.active,\r\n                    isOwner = activeGroup === group,\r\n                    canSort = options.sort,\r\n                    fromSortable = putSortable || activeSortable,\r\n                    vertical,\r\n                    _this = this,\r\n                    completedFired = false;\r\n\r\n                if (_silent) return;\r\n\r\n                function dragOverEvent(name, extra) {\r\n                    pluginEvent(name, _this, _objectSpread({\r\n                        evt: evt,\r\n                        isOwner: isOwner,\r\n                        axis: vertical ? 'vertical' : 'horizontal',\r\n                        revert: revert,\r\n                        dragRect: dragRect,\r\n                        targetRect: targetRect,\r\n                        canSort: canSort,\r\n                        fromSortable: fromSortable,\r\n                        target: target,\r\n                        completed: completed,\r\n                        onMove: function onMove(target, after) {\r\n                            return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\r\n                        },\r\n                        changed: changed\r\n                    }, extra));\r\n                } // Capture animation state\r\n\r\n\r\n                function capture() {\r\n                    dragOverEvent('dragOverAnimationCapture');\r\n\r\n                    _this.captureAnimationState();\r\n\r\n                    if (_this !== fromSortable) {\r\n                        fromSortable.captureAnimationState();\r\n                    }\r\n                } // Return invocation when dragEl is inserted (or completed)\r\n\r\n\r\n                function completed(insertion) {\r\n                    dragOverEvent('dragOverCompleted', {\r\n                        insertion: insertion\r\n                    });\r\n\r\n                    if (insertion) {\r\n                        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\r\n                        if (isOwner) {\r\n                            activeSortable._hideClone();\r\n                        } else {\r\n                            activeSortable._showClone(_this);\r\n                        }\r\n\r\n                        if (_this !== fromSortable) {\r\n                            // Set ghost class to new sortable's ghost class\r\n                            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\r\n                            toggleClass(dragEl, options.ghostClass, true);\r\n                        }\r\n\r\n                        if (putSortable !== _this && _this !== Sortable.active) {\r\n                            putSortable = _this;\r\n                        } else if (_this === Sortable.active && putSortable) {\r\n                            putSortable = null;\r\n                        } // Animation\r\n\r\n\r\n                        if (fromSortable === _this) {\r\n                            _this._ignoreWhileAnimating = target;\r\n                        }\r\n\r\n                        _this.animateAll(function () {\r\n                            dragOverEvent('dragOverAnimationComplete');\r\n                            _this._ignoreWhileAnimating = null;\r\n                        });\r\n\r\n                        if (_this !== fromSortable) {\r\n                            fromSortable.animateAll();\r\n                            fromSortable._ignoreWhileAnimating = null;\r\n                        }\r\n                    } // Null lastTarget if it is not inside a previously swapped element\r\n\r\n\r\n                    if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\r\n                        lastTarget = null;\r\n                    } // no bubbling and not fallback\r\n\r\n\r\n                    if (!options.dragoverBubble && !evt.rootEl && target !== document) {\r\n                        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted\r\n\r\n\r\n                        !insertion && nearestEmptyInsertDetectEvent(evt);\r\n                    }\r\n\r\n                    !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\r\n                    return completedFired = true;\r\n                } // Call when dragEl has been inserted\r\n\r\n\r\n                function changed() {\r\n                    newIndex = index(dragEl);\r\n                    newDraggableIndex = index(dragEl, options.draggable);\r\n\r\n                    _dispatchEvent({\r\n                        sortable: _this,\r\n                        name: 'change',\r\n                        toEl: el,\r\n                        newIndex: newIndex,\r\n                        newDraggableIndex: newDraggableIndex,\r\n                        originalEvent: evt\r\n                    });\r\n                }\r\n\r\n                if (evt.preventDefault !== void 0) {\r\n                    evt.cancelable && evt.preventDefault();\r\n                }\r\n\r\n                target = closest(target, options.draggable, el, true);\r\n                dragOverEvent('dragOver');\r\n                if (Sortable.eventCanceled) return completedFired;\r\n\r\n                if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\r\n                    return completed(false);\r\n                }\r\n\r\n                ignoreNextClick = false;\r\n\r\n                if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\r\n                    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\r\n                    vertical = this._getDirection(evt, target) === 'vertical';\r\n                    dragRect = getRect(dragEl);\r\n                    dragOverEvent('dragOverValid');\r\n                    if (Sortable.eventCanceled) return completedFired;\r\n\r\n                    if (revert) {\r\n                        parentEl = rootEl; // actualization\r\n\r\n                        capture();\r\n\r\n                        this._hideClone();\r\n\r\n                        dragOverEvent('revert');\r\n\r\n                        if (!Sortable.eventCanceled) {\r\n                            if (nextEl) {\r\n                                rootEl.insertBefore(dragEl, nextEl);\r\n                            } else {\r\n                                rootEl.appendChild(dragEl);\r\n                            }\r\n                        }\r\n\r\n                        return completed(true);\r\n                    }\r\n\r\n                    var elLastChild = lastChild(el, options.draggable);\r\n\r\n                    if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\r\n                        // If already at end of list: Do not insert\r\n                        if (elLastChild === dragEl) {\r\n                            return completed(false);\r\n                        } // assign target only if condition is true\r\n\r\n\r\n                        if (elLastChild && el === evt.target) {\r\n                            target = elLastChild;\r\n                        }\r\n\r\n                        if (target) {\r\n                            targetRect = getRect(target);\r\n                        }\r\n\r\n                        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\r\n                            capture();\r\n                            el.appendChild(dragEl);\r\n                            parentEl = el; // actualization\r\n\r\n                            changed();\r\n                            return completed(true);\r\n                        }\r\n                    } else if (target.parentNode === el) {\r\n                        targetRect = getRect(target);\r\n                        var direction = 0,\r\n                            targetBeforeFirstSwap,\r\n                            differentLevel = dragEl.parentNode !== el,\r\n                            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\r\n                            side1 = vertical ? 'top' : 'left',\r\n                            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\r\n                            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\r\n\r\n                        if (lastTarget !== target) {\r\n                            targetBeforeFirstSwap = targetRect[side1];\r\n                            pastFirstInvertThresh = false;\r\n                            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\r\n                        }\r\n\r\n                        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\r\n                        var sibling;\r\n\r\n                        if (direction !== 0) {\r\n                            // Check if target is beside dragEl in respective direction (ignoring hidden elements)\r\n                            var dragIndex = index(dragEl);\r\n\r\n                            do {\r\n                                dragIndex -= direction;\r\n                                sibling = parentEl.children[dragIndex];\r\n                            } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\r\n                        } // If dragEl is already beside target: Do not insert\r\n\r\n\r\n                        if (direction === 0 || sibling === target) {\r\n                            return completed(false);\r\n                        }\r\n\r\n                        lastTarget = target;\r\n                        lastDirection = direction;\r\n                        var nextSibling = target.nextElementSibling,\r\n                            after = false;\r\n                        after = direction === 1;\r\n\r\n                        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\r\n\r\n                        if (moveVector !== false) {\r\n                            if (moveVector === 1 || moveVector === -1) {\r\n                                after = moveVector === 1;\r\n                            }\r\n\r\n                            _silent = true;\r\n                            setTimeout(_unsilent, 30);\r\n                            capture();\r\n\r\n                            if (after && !nextSibling) {\r\n                                el.appendChild(dragEl);\r\n                            } else {\r\n                                target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\r\n                            } // Undo chrome's scroll adjustment (has no effect on other browsers)\r\n\r\n\r\n                            if (scrolledPastTop) {\r\n                                scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\r\n                            }\r\n\r\n                            parentEl = dragEl.parentNode; // actualization\r\n                            // must be done before animation\r\n\r\n                            if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\r\n                                targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\r\n                            }\r\n\r\n                            changed();\r\n                            return completed(true);\r\n                        }\r\n                    }\r\n\r\n                    if (el.contains(dragEl)) {\r\n                        return completed(false);\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            },\r\n            _ignoreWhileAnimating: null,\r\n            _offMoveEvents: function _offMoveEvents() {\r\n                off(document, 'mousemove', this._onTouchMove);\r\n                off(document, 'touchmove', this._onTouchMove);\r\n                off(document, 'pointermove', this._onTouchMove);\r\n                off(document, 'dragover', nearestEmptyInsertDetectEvent);\r\n                off(document, 'mousemove', nearestEmptyInsertDetectEvent);\r\n                off(document, 'touchmove', nearestEmptyInsertDetectEvent);\r\n            },\r\n            _offUpEvents: function _offUpEvents() {\r\n                var ownerDocument = this.el.ownerDocument;\r\n                off(ownerDocument, 'mouseup', this._onDrop);\r\n                off(ownerDocument, 'touchend', this._onDrop);\r\n                off(ownerDocument, 'pointerup', this._onDrop);\r\n                off(ownerDocument, 'touchcancel', this._onDrop);\r\n                off(document, 'selectstart', this);\r\n            },\r\n            _onDrop: function _onDrop(\r\n                /**Event*/\r\n                evt) {\r\n                var el = this.el,\r\n                    options = this.options; // Get the index of the dragged element within its parent\r\n\r\n                newIndex = index(dragEl);\r\n                newDraggableIndex = index(dragEl, options.draggable);\r\n                pluginEvent('drop', this, {\r\n                    evt: evt\r\n                });\r\n                parentEl = dragEl && dragEl.parentNode; // Get again after plugin event\r\n\r\n                newIndex = index(dragEl);\r\n                newDraggableIndex = index(dragEl, options.draggable);\r\n\r\n                if (Sortable.eventCanceled) {\r\n                    this._nulling();\r\n\r\n                    return;\r\n                }\r\n\r\n                awaitingDragStarted = false;\r\n                isCircumstantialInvert = false;\r\n                pastFirstInvertThresh = false;\r\n                clearInterval(this._loopId);\r\n                clearTimeout(this._dragStartTimer);\r\n\r\n                _cancelNextTick(this.cloneId);\r\n\r\n                _cancelNextTick(this._dragStartId); // Unbind events\r\n\r\n\r\n                if (this.nativeDraggable) {\r\n                    off(document, 'drop', this);\r\n                    off(el, 'dragstart', this._onDragStart);\r\n                }\r\n\r\n                this._offMoveEvents();\r\n\r\n                this._offUpEvents();\r\n\r\n                if (Safari) {\r\n                    css(document.body, 'user-select', '');\r\n                }\r\n\r\n                css(dragEl, 'transform', '');\r\n\r\n                if (evt) {\r\n                    if (moved) {\r\n                        evt.cancelable && evt.preventDefault();\r\n                        !options.dropBubble && evt.stopPropagation();\r\n                    }\r\n\r\n                    ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\r\n\r\n                    if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\r\n                        // Remove clone(s)\r\n                        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\r\n                    }\r\n\r\n                    if (dragEl) {\r\n                        if (this.nativeDraggable) {\r\n                            off(dragEl, 'dragend', this);\r\n                        }\r\n\r\n                        _disableDraggable(dragEl);\r\n\r\n                        dragEl.style['will-change'] = ''; // Remove classes\r\n                        // ghostClass is added in dragStarted\r\n\r\n                        if (moved && !awaitingDragStarted) {\r\n                            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\r\n                        }\r\n\r\n                        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event\r\n\r\n                        _dispatchEvent({\r\n                            sortable: this,\r\n                            name: 'unchoose',\r\n                            toEl: parentEl,\r\n                            newIndex: null,\r\n                            newDraggableIndex: null,\r\n                            originalEvent: evt\r\n                        });\r\n\r\n                        if (rootEl !== parentEl) {\r\n                            if (newIndex >= 0) {\r\n                                // Add event\r\n                                _dispatchEvent({\r\n                                    rootEl: parentEl,\r\n                                    name: 'add',\r\n                                    toEl: parentEl,\r\n                                    fromEl: rootEl,\r\n                                    originalEvent: evt\r\n                                }); // Remove event\r\n\r\n\r\n                                _dispatchEvent({\r\n                                    sortable: this,\r\n                                    name: 'remove',\r\n                                    toEl: parentEl,\r\n                                    originalEvent: evt\r\n                                }); // drag from one list and drop into another\r\n\r\n\r\n                                _dispatchEvent({\r\n                                    rootEl: parentEl,\r\n                                    name: 'sort',\r\n                                    toEl: parentEl,\r\n                                    fromEl: rootEl,\r\n                                    originalEvent: evt\r\n                                });\r\n\r\n                                _dispatchEvent({\r\n                                    sortable: this,\r\n                                    name: 'sort',\r\n                                    toEl: parentEl,\r\n                                    originalEvent: evt\r\n                                });\r\n                            }\r\n\r\n                            putSortable && putSortable.save();\r\n                        } else {\r\n                            if (newIndex !== oldIndex) {\r\n                                if (newIndex >= 0) {\r\n                                    // drag & drop within the same list\r\n                                    _dispatchEvent({\r\n                                        sortable: this,\r\n                                        name: 'update',\r\n                                        toEl: parentEl,\r\n                                        originalEvent: evt\r\n                                    });\r\n\r\n                                    _dispatchEvent({\r\n                                        sortable: this,\r\n                                        name: 'sort',\r\n                                        toEl: parentEl,\r\n                                        originalEvent: evt\r\n                                    });\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (Sortable.active) {\r\n                            /* jshint eqnull:true */\r\n                            if (newIndex == null || newIndex === -1) {\r\n                                newIndex = oldIndex;\r\n                                newDraggableIndex = oldDraggableIndex;\r\n                            }\r\n\r\n                            _dispatchEvent({\r\n                                sortable: this,\r\n                                name: 'end',\r\n                                toEl: parentEl,\r\n                                originalEvent: evt\r\n                            }); // Save sorting\r\n\r\n\r\n                            this.save();\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this._nulling();\r\n            },\r\n            _nulling: function _nulling() {\r\n                pluginEvent('nulling', this);\r\n                rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\r\n                savedInputChecked.forEach(function (el) {\r\n                    el.checked = true;\r\n                });\r\n                savedInputChecked.length = lastDx = lastDy = 0;\r\n            },\r\n            handleEvent: function handleEvent(\r\n                /**Event*/\r\n                evt) {\r\n                switch (evt.type) {\r\n                    case 'drop':\r\n                    case 'dragend':\r\n                        this._onDrop(evt);\r\n\r\n                        break;\r\n\r\n                    case 'dragenter':\r\n                    case 'dragover':\r\n                        if (dragEl) {\r\n                            this._onDragOver(evt);\r\n\r\n                            _globalDragOver(evt);\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case 'selectstart':\r\n                        evt.preventDefault();\r\n                        break;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Serializes the item into an array of string.\r\n             * @returns {String[]}\r\n             */\r\n            toArray: function toArray() {\r\n                var order = [],\r\n                    el,\r\n                    children = this.el.children,\r\n                    i = 0,\r\n                    n = children.length,\r\n                    options = this.options;\r\n\r\n                for (; i < n; i++) {\r\n                    el = children[i];\r\n\r\n                    if (closest(el, options.draggable, this.el, false)) {\r\n                        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\r\n                    }\r\n                }\r\n\r\n                return order;\r\n            },\r\n\r\n            /**\r\n             * Sorts the elements according to the array.\r\n             * @param  {String[]}  order  order of the items\r\n             */\r\n            sort: function sort(order) {\r\n                var items = {},\r\n                    rootEl = this.el;\r\n                this.toArray().forEach(function (id, i) {\r\n                    var el = rootEl.children[i];\r\n\r\n                    if (closest(el, this.options.draggable, rootEl, false)) {\r\n                        items[id] = el;\r\n                    }\r\n                }, this);\r\n                order.forEach(function (id) {\r\n                    if (items[id]) {\r\n                        rootEl.removeChild(items[id]);\r\n                        rootEl.appendChild(items[id]);\r\n                    }\r\n                });\r\n            },\r\n\r\n            /**\r\n             * Save the current sorting\r\n             */\r\n            save: function save() {\r\n                var store = this.options.store;\r\n                store && store.set && store.set(this);\r\n            },\r\n\r\n            /**\r\n             * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\r\n             * @param   {HTMLElement}  el\r\n             * @param   {String}       [selector]  default: `options.draggable`\r\n             * @returns {HTMLElement|null}\r\n             */\r\n            closest: function closest$1(el, selector) {\r\n                return closest(el, selector || this.options.draggable, this.el, false);\r\n            },\r\n\r\n            /**\r\n             * Set/get option\r\n             * @param   {string} name\r\n             * @param   {*}      [value]\r\n             * @returns {*}\r\n             */\r\n            option: function option(name, value) {\r\n                var options = this.options;\r\n\r\n                if (value === void 0) {\r\n                    return options[name];\r\n                } else {\r\n                    var modifiedValue = PluginManager.modifyOption(this, name, value);\r\n\r\n                    if (typeof modifiedValue !== 'undefined') {\r\n                        options[name] = modifiedValue;\r\n                    } else {\r\n                        options[name] = value;\r\n                    }\r\n\r\n                    if (name === 'group') {\r\n                        _prepareGroup(options);\r\n                    }\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Destroy\r\n             */\r\n            destroy: function destroy() {\r\n                pluginEvent('destroy', this);\r\n                var el = this.el;\r\n                el[expando] = null;\r\n                off(el, 'mousedown', this._onTapStart);\r\n                off(el, 'touchstart', this._onTapStart);\r\n                off(el, 'pointerdown', this._onTapStart);\r\n\r\n                if (this.nativeDraggable) {\r\n                    off(el, 'dragover', this);\r\n                    off(el, 'dragenter', this);\r\n                } // Remove draggable attributes\r\n\r\n\r\n                Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\r\n                    el.removeAttribute('draggable');\r\n                });\r\n\r\n                this._onDrop();\r\n\r\n                this._disableDelayedDragEvents();\r\n\r\n                sortables.splice(sortables.indexOf(this.el), 1);\r\n                this.el = el = null;\r\n            },\r\n            _hideClone: function _hideClone() {\r\n                if (!cloneHidden) {\r\n                    pluginEvent('hideClone', this);\r\n                    if (Sortable.eventCanceled) return;\r\n                    css(cloneEl, 'display', 'none');\r\n\r\n                    if (this.options.removeCloneOnHide && cloneEl.parentNode) {\r\n                        cloneEl.parentNode.removeChild(cloneEl);\r\n                    }\r\n\r\n                    cloneHidden = true;\r\n                }\r\n            },\r\n            _showClone: function _showClone(putSortable) {\r\n                if (putSortable.lastPutMode !== 'clone') {\r\n                    this._hideClone();\r\n\r\n                    return;\r\n                }\r\n\r\n                if (cloneHidden) {\r\n                    pluginEvent('showClone', this);\r\n                    if (Sortable.eventCanceled) return; // show clone at dragEl or original position\r\n\r\n                    if (rootEl.contains(dragEl) && !this.options.group.revertClone) {\r\n                        rootEl.insertBefore(cloneEl, dragEl);\r\n                    } else if (nextEl) {\r\n                        rootEl.insertBefore(cloneEl, nextEl);\r\n                    } else {\r\n                        rootEl.appendChild(cloneEl);\r\n                    }\r\n\r\n                    if (this.options.group.revertClone) {\r\n                        this.animate(dragEl, cloneEl);\r\n                    }\r\n\r\n                    css(cloneEl, 'display', '');\r\n                    cloneHidden = false;\r\n                }\r\n            }\r\n        };\r\n\r\n    function _globalDragOver(\r\n        /**Event*/\r\n        evt) {\r\n        if (evt.dataTransfer) {\r\n            evt.dataTransfer.dropEffect = 'move';\r\n        }\r\n\r\n        evt.cancelable && evt.preventDefault();\r\n    }\r\n\r\n    function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\r\n        var evt,\r\n            sortable = fromEl[expando],\r\n            onMoveFn = sortable.options.onMove,\r\n            retVal; // Support for new CustomEvent feature\r\n\r\n        if (window.CustomEvent && !IE11OrLess && !Edge) {\r\n            evt = new CustomEvent('move', {\r\n                bubbles: true,\r\n                cancelable: true\r\n            });\r\n        } else {\r\n            evt = document.createEvent('Event');\r\n            evt.initEvent('move', true, true);\r\n        }\r\n\r\n        evt.to = toEl;\r\n        evt.from = fromEl;\r\n        evt.dragged = dragEl;\r\n        evt.draggedRect = dragRect;\r\n        evt.related = targetEl || toEl;\r\n        evt.relatedRect = targetRect || getRect(toEl);\r\n        evt.willInsertAfter = willInsertAfter;\r\n        evt.originalEvent = originalEvent;\r\n        fromEl.dispatchEvent(evt);\r\n\r\n        if (onMoveFn) {\r\n            retVal = onMoveFn.call(sortable, evt, originalEvent);\r\n        }\r\n\r\n        return retVal;\r\n    }\r\n\r\n    function _disableDraggable(el) {\r\n        el.draggable = false;\r\n    }\r\n\r\n    function _unsilent() {\r\n        _silent = false;\r\n    }\r\n\r\n    function _ghostIsLast(evt, vertical, sortable) {\r\n        var rect = getRect(lastChild(sortable.el, sortable.options.draggable));\r\n        var spacer = 10;\r\n        return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;\r\n    }\r\n\r\n    function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\r\n        var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\r\n            targetLength = vertical ? targetRect.height : targetRect.width,\r\n            targetS1 = vertical ? targetRect.top : targetRect.left,\r\n            targetS2 = vertical ? targetRect.bottom : targetRect.right,\r\n            invert = false;\r\n\r\n        if (!invertSwap) {\r\n            // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\r\n            if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\r\n                // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\r\n                // check if past first invert threshold on side opposite of lastDirection\r\n                if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\r\n                    // past first invert threshold, do not restrict inverted threshold to dragEl shadow\r\n                    pastFirstInvertThresh = true;\r\n                }\r\n\r\n                if (!pastFirstInvertThresh) {\r\n                    // dragEl shadow (target move distance shadow)\r\n                    if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\r\n                        : mouseOnAxis > targetS2 - targetMoveDistance) {\r\n                        return -lastDirection;\r\n                    }\r\n                } else {\r\n                    invert = true;\r\n                }\r\n            } else {\r\n                // Regular\r\n                if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\r\n                    return _getInsertDirection(target);\r\n                }\r\n            }\r\n        }\r\n\r\n        invert = invert || invertSwap;\r\n\r\n        if (invert) {\r\n            // Invert of regular\r\n            if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\r\n                return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n    /**\r\n     * Gets the direction dragEl must be swapped relative to target in order to make it\r\n     * seem that dragEl has been \"inserted\" into that element's position\r\n     * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\r\n     * @return {Number}                   Direction dragEl must be swapped\r\n     */\r\n\r\n\r\n    function _getInsertDirection(target) {\r\n        if (index(dragEl) < index(target)) {\r\n            return 1;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    /**\r\n     * Generate id\r\n     * @param   {HTMLElement} el\r\n     * @returns {String}\r\n     * @private\r\n     */\r\n\r\n\r\n    function _generateId(el) {\r\n        var str = el.tagName + el.className + el.src + el.href + el.textContent,\r\n            i = str.length,\r\n            sum = 0;\r\n\r\n        while (i--) {\r\n            sum += str.charCodeAt(i);\r\n        }\r\n\r\n        return sum.toString(36);\r\n    }\r\n\r\n    function _saveInputCheckedState(root) {\r\n        savedInputChecked.length = 0;\r\n        var inputs = root.getElementsByTagName('input');\r\n        var idx = inputs.length;\r\n\r\n        while (idx--) {\r\n            var el = inputs[idx];\r\n            el.checked && savedInputChecked.push(el);\r\n        }\r\n    }\r\n\r\n    function _nextTick(fn) {\r\n        return setTimeout(fn, 0);\r\n    }\r\n\r\n    function _cancelNextTick(id) {\r\n        return clearTimeout(id);\r\n    } // Fixed #973:\r\n\r\n\r\n    if (documentExists) {\r\n        on(document, 'touchmove', function (evt) {\r\n            if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\r\n                evt.preventDefault();\r\n            }\r\n        });\r\n    } // Export utils\r\n\r\n\r\n    Sortable.utils = {\r\n        on: on,\r\n        off: off,\r\n        css: css,\r\n        find: find,\r\n        is: function is(el, selector) {\r\n            return !!closest(el, selector, el, false);\r\n        },\r\n        extend: extend,\r\n        throttle: throttle,\r\n        closest: closest,\r\n        toggleClass: toggleClass,\r\n        clone: clone,\r\n        index: index,\r\n        nextTick: _nextTick,\r\n        cancelNextTick: _cancelNextTick,\r\n        detectDirection: _detectDirection,\r\n        getChild: getChild\r\n    };\r\n    /**\r\n     * Get the Sortable instance of an element\r\n     * @param  {HTMLElement} element The element\r\n     * @return {Sortable|undefined}         The instance of Sortable\r\n     */\r\n\r\n    Sortable.get = function (element) {\r\n        return element[expando];\r\n    };\r\n    /**\r\n     * Mount a plugin to Sortable\r\n     * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\r\n     */\r\n\r\n\r\n    Sortable.mount = function () {\r\n        for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\r\n            plugins[_key] = arguments[_key];\r\n        }\r\n\r\n        if (plugins[0].constructor === Array) plugins = plugins[0];\r\n        plugins.forEach(function (plugin) {\r\n            if (!plugin.prototype || !plugin.prototype.constructor) {\r\n                throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\r\n            }\r\n\r\n            if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);\r\n            PluginManager.mount(plugin);\r\n        });\r\n    };\r\n    /**\r\n     * Create sortable instance\r\n     * @param {HTMLElement}  el\r\n     * @param {Object}      [options]\r\n     */\r\n\r\n\r\n    Sortable.create = function (el, options) {\r\n        return new Sortable(el, options);\r\n    }; // Export\r\n\r\n\r\n    Sortable.version = version;\r\n\r\n    var autoScrolls = [],\r\n        scrollEl,\r\n        scrollRootEl,\r\n        scrolling = false,\r\n        lastAutoScrollX,\r\n        lastAutoScrollY,\r\n        touchEvt$1,\r\n        pointerElemChangedInterval;\r\n\r\n    function AutoScrollPlugin() {\r\n        function AutoScroll() {\r\n            this.defaults = {\r\n                scroll: true,\r\n                scrollSensitivity: 30,\r\n                scrollSpeed: 10,\r\n                bubbleScroll: true\r\n            }; // Bind all private methods\r\n\r\n            for (var fn in this) {\r\n                if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\r\n                    this[fn] = this[fn].bind(this);\r\n                }\r\n            }\r\n        }\r\n\r\n        AutoScroll.prototype = {\r\n            dragStarted: function dragStarted(_ref) {\r\n                var originalEvent = _ref.originalEvent;\r\n\r\n                if (this.sortable.nativeDraggable) {\r\n                    on(document, 'dragover', this._handleAutoScroll);\r\n                } else {\r\n                    if (this.options.supportPointer) {\r\n                        on(document, 'pointermove', this._handleFallbackAutoScroll);\r\n                    } else if (originalEvent.touches) {\r\n                        on(document, 'touchmove', this._handleFallbackAutoScroll);\r\n                    } else {\r\n                        on(document, 'mousemove', this._handleFallbackAutoScroll);\r\n                    }\r\n                }\r\n            },\r\n            dragOverCompleted: function dragOverCompleted(_ref2) {\r\n                var originalEvent = _ref2.originalEvent;\r\n\r\n                // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\r\n                if (!this.options.dragOverBubble && !originalEvent.rootEl) {\r\n                    this._handleAutoScroll(originalEvent);\r\n                }\r\n            },\r\n            drop: function drop() {\r\n                if (this.sortable.nativeDraggable) {\r\n                    off(document, 'dragover', this._handleAutoScroll);\r\n                } else {\r\n                    off(document, 'pointermove', this._handleFallbackAutoScroll);\r\n                    off(document, 'touchmove', this._handleFallbackAutoScroll);\r\n                    off(document, 'mousemove', this._handleFallbackAutoScroll);\r\n                }\r\n\r\n                clearPointerElemChangedInterval();\r\n                clearAutoScrolls();\r\n                cancelThrottle();\r\n            },\r\n            nulling: function nulling() {\r\n                touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\r\n                autoScrolls.length = 0;\r\n            },\r\n            _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\r\n                this._handleAutoScroll(evt, true);\r\n            },\r\n            _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\r\n                var _this = this;\r\n\r\n                var x = (evt.touches ? evt.touches[0] : evt).clientX,\r\n                    y = (evt.touches ? evt.touches[0] : evt).clientY,\r\n                    elem = document.elementFromPoint(x, y);\r\n                touchEvt$1 = evt; // IE does not seem to have native autoscroll,\r\n                // Edge's autoscroll seems too conditional,\r\n                // MACOS Safari does not have autoscroll,\r\n                // Firefox and Chrome are good\r\n\r\n                if (fallback || Edge || IE11OrLess || Safari) {\r\n                    autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change\r\n\r\n                    var ogElemScroller = getParentAutoScrollElement(elem, true);\r\n\r\n                    if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\r\n                        pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour\r\n\r\n                        pointerElemChangedInterval = setInterval(function () {\r\n                            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\r\n\r\n                            if (newElem !== ogElemScroller) {\r\n                                ogElemScroller = newElem;\r\n                                clearAutoScrolls();\r\n                            }\r\n\r\n                            autoScroll(evt, _this.options, newElem, fallback);\r\n                        }, 10);\r\n                        lastAutoScrollX = x;\r\n                        lastAutoScrollY = y;\r\n                    }\r\n                } else {\r\n                    // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\r\n                    if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\r\n                        clearAutoScrolls();\r\n                        return;\r\n                    }\r\n\r\n                    autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\r\n                }\r\n            }\r\n        };\r\n        return _extends(AutoScroll, {\r\n            pluginName: 'scroll',\r\n            initializeByDefault: true\r\n        });\r\n    }\r\n\r\n    function clearAutoScrolls() {\r\n        autoScrolls.forEach(function (autoScroll) {\r\n            clearInterval(autoScroll.pid);\r\n        });\r\n        autoScrolls = [];\r\n    }\r\n\r\n    function clearPointerElemChangedInterval() {\r\n        clearInterval(pointerElemChangedInterval);\r\n    }\r\n\r\n    var autoScroll = throttle(function (evt, options, rootEl, isFallback) {\r\n        // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\r\n        if (!options.scroll) return;\r\n        var x = (evt.touches ? evt.touches[0] : evt).clientX,\r\n            y = (evt.touches ? evt.touches[0] : evt).clientY,\r\n            sens = options.scrollSensitivity,\r\n            speed = options.scrollSpeed,\r\n            winScroller = getWindowScrollingElement();\r\n        var scrollThisInstance = false,\r\n            scrollCustomFn; // New scroll root, set scrollEl\r\n\r\n        if (scrollRootEl !== rootEl) {\r\n            scrollRootEl = rootEl;\r\n            clearAutoScrolls();\r\n            scrollEl = options.scroll;\r\n            scrollCustomFn = options.scrollFn;\r\n\r\n            if (scrollEl === true) {\r\n                scrollEl = getParentAutoScrollElement(rootEl, true);\r\n            }\r\n        }\r\n\r\n        var layersOut = 0;\r\n        var currentParent = scrollEl;\r\n\r\n        do {\r\n            var el = currentParent,\r\n                rect = getRect(el),\r\n                top = rect.top,\r\n                bottom = rect.bottom,\r\n                left = rect.left,\r\n                right = rect.right,\r\n                width = rect.width,\r\n                height = rect.height,\r\n                canScrollX = void 0,\r\n                canScrollY = void 0,\r\n                scrollWidth = el.scrollWidth,\r\n                scrollHeight = el.scrollHeight,\r\n                elCSS = css(el),\r\n                scrollPosX = el.scrollLeft,\r\n                scrollPosY = el.scrollTop;\r\n\r\n            if (el === winScroller) {\r\n                canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\r\n                canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\r\n            } else {\r\n                canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\r\n                canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\r\n            }\r\n\r\n            var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\r\n            var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\r\n\r\n            if (!autoScrolls[layersOut]) {\r\n                for (var i = 0; i <= layersOut; i++) {\r\n                    if (!autoScrolls[i]) {\r\n                        autoScrolls[i] = {};\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\r\n                autoScrolls[layersOut].el = el;\r\n                autoScrolls[layersOut].vx = vx;\r\n                autoScrolls[layersOut].vy = vy;\r\n                clearInterval(autoScrolls[layersOut].pid);\r\n\r\n                if (vx != 0 || vy != 0) {\r\n                    scrollThisInstance = true;\r\n                    /* jshint loopfunc:true */\r\n\r\n                    autoScrolls[layersOut].pid = setInterval(function () {\r\n                        // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\r\n                        if (isFallback && this.layer === 0) {\r\n                            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\r\n\r\n                        }\r\n\r\n                        var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\r\n                        var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\r\n\r\n                        if (typeof scrollCustomFn === 'function') {\r\n                            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                        scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\r\n                    }.bind({\r\n                        layer: layersOut\r\n                    }), 24);\r\n                }\r\n            }\r\n\r\n            layersOut++;\r\n        } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\r\n\r\n        scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\r\n    }, 30);\r\n\r\n    var drop = function drop(_ref) {\r\n        var originalEvent = _ref.originalEvent,\r\n            putSortable = _ref.putSortable,\r\n            dragEl = _ref.dragEl,\r\n            activeSortable = _ref.activeSortable,\r\n            dispatchSortableEvent = _ref.dispatchSortableEvent,\r\n            hideGhostForTarget = _ref.hideGhostForTarget,\r\n            unhideGhostForTarget = _ref.unhideGhostForTarget;\r\n        if (!originalEvent) return;\r\n        var toSortable = putSortable || activeSortable;\r\n        hideGhostForTarget();\r\n        var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\r\n        var target = document.elementFromPoint(touch.clientX, touch.clientY);\r\n        unhideGhostForTarget();\r\n\r\n        if (toSortable && !toSortable.el.contains(target)) {\r\n            dispatchSortableEvent('spill');\r\n            this.onSpill({\r\n                dragEl: dragEl,\r\n                putSortable: putSortable\r\n            });\r\n        }\r\n    };\r\n\r\n    function Revert() {}\r\n\r\n    Revert.prototype = {\r\n        startIndex: null,\r\n        dragStart: function dragStart(_ref2) {\r\n            var oldDraggableIndex = _ref2.oldDraggableIndex;\r\n            this.startIndex = oldDraggableIndex;\r\n        },\r\n        onSpill: function onSpill(_ref3) {\r\n            var dragEl = _ref3.dragEl,\r\n                putSortable = _ref3.putSortable;\r\n            this.sortable.captureAnimationState();\r\n\r\n            if (putSortable) {\r\n                putSortable.captureAnimationState();\r\n            }\r\n\r\n            var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\r\n\r\n            if (nextSibling) {\r\n                this.sortable.el.insertBefore(dragEl, nextSibling);\r\n            } else {\r\n                this.sortable.el.appendChild(dragEl);\r\n            }\r\n\r\n            this.sortable.animateAll();\r\n\r\n            if (putSortable) {\r\n                putSortable.animateAll();\r\n            }\r\n        },\r\n        drop: drop\r\n    };\r\n\r\n    _extends(Revert, {\r\n        pluginName: 'revertOnSpill'\r\n    });\r\n\r\n    function Remove() {}\r\n\r\n    Remove.prototype = {\r\n        onSpill: function onSpill(_ref4) {\r\n            var dragEl = _ref4.dragEl,\r\n                putSortable = _ref4.putSortable;\r\n            var parentSortable = putSortable || this.sortable;\r\n            parentSortable.captureAnimationState();\r\n            dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\r\n            parentSortable.animateAll();\r\n        },\r\n        drop: drop\r\n    };\r\n\r\n    _extends(Remove, {\r\n        pluginName: 'removeOnSpill'\r\n    });\r\n\r\n    var lastSwapEl;\r\n\r\n    function SwapPlugin() {\r\n        function Swap() {\r\n            this.defaults = {\r\n                swapClass: 'sortable-swap-highlight'\r\n            };\r\n        }\r\n\r\n        Swap.prototype = {\r\n            dragStart: function dragStart(_ref) {\r\n                var dragEl = _ref.dragEl;\r\n                lastSwapEl = dragEl;\r\n            },\r\n            dragOverValid: function dragOverValid(_ref2) {\r\n                var completed = _ref2.completed,\r\n                    target = _ref2.target,\r\n                    onMove = _ref2.onMove,\r\n                    activeSortable = _ref2.activeSortable,\r\n                    changed = _ref2.changed,\r\n                    cancel = _ref2.cancel;\r\n                if (!activeSortable.options.swap) return;\r\n                var el = this.sortable.el,\r\n                    options = this.options;\r\n\r\n                if (target && target !== el) {\r\n                    var prevSwapEl = lastSwapEl;\r\n\r\n                    if (onMove(target) !== false) {\r\n                        toggleClass(target, options.swapClass, true);\r\n                        lastSwapEl = target;\r\n                    } else {\r\n                        lastSwapEl = null;\r\n                    }\r\n\r\n                    if (prevSwapEl && prevSwapEl !== lastSwapEl) {\r\n                        toggleClass(prevSwapEl, options.swapClass, false);\r\n                    }\r\n                }\r\n\r\n                changed();\r\n                completed(true);\r\n                cancel();\r\n            },\r\n            drop: function drop(_ref3) {\r\n                var activeSortable = _ref3.activeSortable,\r\n                    putSortable = _ref3.putSortable,\r\n                    dragEl = _ref3.dragEl;\r\n                var toSortable = putSortable || this.sortable;\r\n                var options = this.options;\r\n                lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\r\n\r\n                if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\r\n                    if (dragEl !== lastSwapEl) {\r\n                        toSortable.captureAnimationState();\r\n                        if (toSortable !== activeSortable) activeSortable.captureAnimationState();\r\n                        swapNodes(dragEl, lastSwapEl);\r\n                        toSortable.animateAll();\r\n                        if (toSortable !== activeSortable) activeSortable.animateAll();\r\n                    }\r\n                }\r\n            },\r\n            nulling: function nulling() {\r\n                lastSwapEl = null;\r\n            }\r\n        };\r\n        return _extends(Swap, {\r\n            pluginName: 'swap',\r\n            eventProperties: function eventProperties() {\r\n                return {\r\n                    swapItem: lastSwapEl\r\n                };\r\n            }\r\n        });\r\n    }\r\n\r\n    function swapNodes(n1, n2) {\r\n        var p1 = n1.parentNode,\r\n            p2 = n2.parentNode,\r\n            i1,\r\n            i2;\r\n        if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\r\n        i1 = index(n1);\r\n        i2 = index(n2);\r\n\r\n        if (p1.isEqualNode(p2) && i1 < i2) {\r\n            i2++;\r\n        }\r\n\r\n        p1.insertBefore(n2, p1.children[i1]);\r\n        p2.insertBefore(n1, p2.children[i2]);\r\n    }\r\n\r\n    var multiDragElements = [],\r\n        multiDragClones = [],\r\n        lastMultiDragSelect,\r\n        // for selection with modifier key down (SHIFT)\r\n        multiDragSortable,\r\n        initialFolding = false,\r\n        // Initial multi-drag fold when drag started\r\n        folding = false,\r\n        // Folding any other time\r\n        dragStarted = false,\r\n        dragEl$1,\r\n        clonesFromRect,\r\n        clonesHidden;\r\n\r\n    function MultiDragPlugin() {\r\n        function MultiDrag(sortable) {\r\n            // Bind all private methods\r\n            for (var fn in this) {\r\n                if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\r\n                    this[fn] = this[fn].bind(this);\r\n                }\r\n            }\r\n\r\n            if (sortable.options.supportPointer) {\r\n                on(document, 'pointerup', this._deselectMultiDrag);\r\n            } else {\r\n                on(document, 'mouseup', this._deselectMultiDrag);\r\n                on(document, 'touchend', this._deselectMultiDrag);\r\n            }\r\n\r\n            on(document, 'keydown', this._checkKeyDown);\r\n            on(document, 'keyup', this._checkKeyUp);\r\n            this.defaults = {\r\n                selectedClass: 'sortable-selected',\r\n                multiDragKey: null,\r\n                setData: function setData(dataTransfer, dragEl) {\r\n                    var data = '';\r\n\r\n                    if (multiDragElements.length && multiDragSortable === sortable) {\r\n                        multiDragElements.forEach(function (multiDragElement, i) {\r\n                            data += (!i ? '' : ', ') + multiDragElement.textContent;\r\n                        });\r\n                    } else {\r\n                        data = dragEl.textContent;\r\n                    }\r\n\r\n                    dataTransfer.setData('Text', data);\r\n                }\r\n            };\r\n        }\r\n\r\n        MultiDrag.prototype = {\r\n            multiDragKeyDown: false,\r\n            isMultiDrag: false,\r\n            delayStartGlobal: function delayStartGlobal(_ref) {\r\n                var dragged = _ref.dragEl;\r\n                dragEl$1 = dragged;\r\n            },\r\n            delayEnded: function delayEnded() {\r\n                this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\r\n            },\r\n            setupClone: function setupClone(_ref2) {\r\n                var sortable = _ref2.sortable,\r\n                    cancel = _ref2.cancel;\r\n                if (!this.isMultiDrag) return;\r\n\r\n                for (var i = 0; i < multiDragElements.length; i++) {\r\n                    multiDragClones.push(clone(multiDragElements[i]));\r\n                    multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\r\n                    multiDragClones[i].draggable = false;\r\n                    multiDragClones[i].style['will-change'] = '';\r\n                    toggleClass(multiDragClones[i], this.options.selectedClass, false);\r\n                    multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\r\n                }\r\n\r\n                sortable._hideClone();\r\n\r\n                cancel();\r\n            },\r\n            clone: function clone(_ref3) {\r\n                var sortable = _ref3.sortable,\r\n                    rootEl = _ref3.rootEl,\r\n                    dispatchSortableEvent = _ref3.dispatchSortableEvent,\r\n                    cancel = _ref3.cancel;\r\n                if (!this.isMultiDrag) return;\r\n\r\n                if (!this.options.removeCloneOnHide) {\r\n                    if (multiDragElements.length && multiDragSortable === sortable) {\r\n                        insertMultiDragClones(true, rootEl);\r\n                        dispatchSortableEvent('clone');\r\n                        cancel();\r\n                    }\r\n                }\r\n            },\r\n            showClone: function showClone(_ref4) {\r\n                var cloneNowShown = _ref4.cloneNowShown,\r\n                    rootEl = _ref4.rootEl,\r\n                    cancel = _ref4.cancel;\r\n                if (!this.isMultiDrag) return;\r\n                insertMultiDragClones(false, rootEl);\r\n                multiDragClones.forEach(function (clone) {\r\n                    css(clone, 'display', '');\r\n                });\r\n                cloneNowShown();\r\n                clonesHidden = false;\r\n                cancel();\r\n            },\r\n            hideClone: function hideClone(_ref5) {\r\n                var _this = this;\r\n\r\n                var sortable = _ref5.sortable,\r\n                    cloneNowHidden = _ref5.cloneNowHidden,\r\n                    cancel = _ref5.cancel;\r\n                if (!this.isMultiDrag) return;\r\n                multiDragClones.forEach(function (clone) {\r\n                    css(clone, 'display', 'none');\r\n\r\n                    if (_this.options.removeCloneOnHide && clone.parentNode) {\r\n                        clone.parentNode.removeChild(clone);\r\n                    }\r\n                });\r\n                cloneNowHidden();\r\n                clonesHidden = true;\r\n                cancel();\r\n            },\r\n            dragStartGlobal: function dragStartGlobal(_ref6) {\r\n                var sortable = _ref6.sortable;\r\n\r\n                if (!this.isMultiDrag && multiDragSortable) {\r\n                    multiDragSortable.multiDrag._deselectMultiDrag();\r\n                }\r\n\r\n                multiDragElements.forEach(function (multiDragElement) {\r\n                    multiDragElement.sortableIndex = index(multiDragElement);\r\n                }); // Sort multi-drag elements\r\n\r\n                multiDragElements = multiDragElements.sort(function (a, b) {\r\n                    return a.sortableIndex - b.sortableIndex;\r\n                });\r\n                dragStarted = true;\r\n            },\r\n            dragStarted: function dragStarted(_ref7) {\r\n                var _this2 = this;\r\n\r\n                var sortable = _ref7.sortable;\r\n                if (!this.isMultiDrag) return;\r\n\r\n                if (this.options.sort) {\r\n                    // Capture rects,\r\n                    // hide multi drag elements (by positioning them absolute),\r\n                    // set multi drag elements rects to dragRect,\r\n                    // show multi drag elements,\r\n                    // animate to rects,\r\n                    // unset rects & remove from DOM\r\n                    sortable.captureAnimationState();\r\n\r\n                    if (this.options.animation) {\r\n                        multiDragElements.forEach(function (multiDragElement) {\r\n                            if (multiDragElement === dragEl$1) return;\r\n                            css(multiDragElement, 'position', 'absolute');\r\n                        });\r\n                        var dragRect = getRect(dragEl$1, false, true, true);\r\n                        multiDragElements.forEach(function (multiDragElement) {\r\n                            if (multiDragElement === dragEl$1) return;\r\n                            setRect(multiDragElement, dragRect);\r\n                        });\r\n                        folding = true;\r\n                        initialFolding = true;\r\n                    }\r\n                }\r\n\r\n                sortable.animateAll(function () {\r\n                    folding = false;\r\n                    initialFolding = false;\r\n\r\n                    if (_this2.options.animation) {\r\n                        multiDragElements.forEach(function (multiDragElement) {\r\n                            unsetRect(multiDragElement);\r\n                        });\r\n                    } // Remove all auxiliary multidrag items from el, if sorting enabled\r\n\r\n\r\n                    if (_this2.options.sort) {\r\n                        removeMultiDragElements();\r\n                    }\r\n                });\r\n            },\r\n            dragOver: function dragOver(_ref8) {\r\n                var target = _ref8.target,\r\n                    completed = _ref8.completed,\r\n                    cancel = _ref8.cancel;\r\n\r\n                if (folding && ~multiDragElements.indexOf(target)) {\r\n                    completed(false);\r\n                    cancel();\r\n                }\r\n            },\r\n            revert: function revert(_ref9) {\r\n                var fromSortable = _ref9.fromSortable,\r\n                    rootEl = _ref9.rootEl,\r\n                    sortable = _ref9.sortable,\r\n                    dragRect = _ref9.dragRect;\r\n\r\n                if (multiDragElements.length > 1) {\r\n                    // Setup unfold animation\r\n                    multiDragElements.forEach(function (multiDragElement) {\r\n                        sortable.addAnimationState({\r\n                            target: multiDragElement,\r\n                            rect: folding ? getRect(multiDragElement) : dragRect\r\n                        });\r\n                        unsetRect(multiDragElement);\r\n                        multiDragElement.fromRect = dragRect;\r\n                        fromSortable.removeAnimationState(multiDragElement);\r\n                    });\r\n                    folding = false;\r\n                    insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\r\n                }\r\n            },\r\n            dragOverCompleted: function dragOverCompleted(_ref10) {\r\n                var sortable = _ref10.sortable,\r\n                    isOwner = _ref10.isOwner,\r\n                    insertion = _ref10.insertion,\r\n                    activeSortable = _ref10.activeSortable,\r\n                    parentEl = _ref10.parentEl,\r\n                    putSortable = _ref10.putSortable;\r\n                var options = this.options;\r\n\r\n                if (insertion) {\r\n                    // Clones must be hidden before folding animation to capture dragRectAbsolute properly\r\n                    if (isOwner) {\r\n                        activeSortable._hideClone();\r\n                    }\r\n\r\n                    initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location\r\n\r\n                    if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\r\n                        // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\r\n                        var dragRectAbsolute = getRect(dragEl$1, false, true, true);\r\n                        multiDragElements.forEach(function (multiDragElement) {\r\n                            if (multiDragElement === dragEl$1) return;\r\n                            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\r\n                            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\r\n\r\n                            parentEl.appendChild(multiDragElement);\r\n                        });\r\n                        folding = true;\r\n                    } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\r\n\r\n\r\n                    if (!isOwner) {\r\n                        // Only remove if not folding (folding will remove them anyways)\r\n                        if (!folding) {\r\n                            removeMultiDragElements();\r\n                        }\r\n\r\n                        if (multiDragElements.length > 1) {\r\n                            var clonesHiddenBefore = clonesHidden;\r\n\r\n                            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden\r\n\r\n\r\n                            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\r\n                                multiDragClones.forEach(function (clone) {\r\n                                    activeSortable.addAnimationState({\r\n                                        target: clone,\r\n                                        rect: clonesFromRect\r\n                                    });\r\n                                    clone.fromRect = clonesFromRect;\r\n                                    clone.thisAnimationDuration = null;\r\n                                });\r\n                            }\r\n                        } else {\r\n                            activeSortable._showClone(sortable);\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\r\n                var dragRect = _ref11.dragRect,\r\n                    isOwner = _ref11.isOwner,\r\n                    activeSortable = _ref11.activeSortable;\r\n                multiDragElements.forEach(function (multiDragElement) {\r\n                    multiDragElement.thisAnimationDuration = null;\r\n                });\r\n\r\n                if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\r\n                    clonesFromRect = _extends({}, dragRect);\r\n                    var dragMatrix = matrix(dragEl$1, true);\r\n                    clonesFromRect.top -= dragMatrix.f;\r\n                    clonesFromRect.left -= dragMatrix.e;\r\n                }\r\n            },\r\n            dragOverAnimationComplete: function dragOverAnimationComplete() {\r\n                if (folding) {\r\n                    folding = false;\r\n                    removeMultiDragElements();\r\n                }\r\n            },\r\n            drop: function drop(_ref12) {\r\n                var evt = _ref12.originalEvent,\r\n                    rootEl = _ref12.rootEl,\r\n                    parentEl = _ref12.parentEl,\r\n                    sortable = _ref12.sortable,\r\n                    dispatchSortableEvent = _ref12.dispatchSortableEvent,\r\n                    oldIndex = _ref12.oldIndex,\r\n                    putSortable = _ref12.putSortable;\r\n                var toSortable = putSortable || this.sortable;\r\n                if (!evt) return;\r\n                var options = this.options,\r\n                    children = parentEl.children; // Multi-drag selection\r\n\r\n                if (!dragStarted) {\r\n                    if (options.multiDragKey && !this.multiDragKeyDown) {\r\n                        this._deselectMultiDrag();\r\n                    }\r\n\r\n                    toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\r\n\r\n                    if (!~multiDragElements.indexOf(dragEl$1)) {\r\n                        multiDragElements.push(dragEl$1);\r\n                        dispatchEvent({\r\n                            sortable: sortable,\r\n                            rootEl: rootEl,\r\n                            name: 'select',\r\n                            targetEl: dragEl$1,\r\n                            originalEvt: evt\r\n                        }); // Modifier activated, select from last to dragEl\r\n\r\n                        if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\r\n                            var lastIndex = index(lastMultiDragSelect),\r\n                                currentIndex = index(dragEl$1);\r\n\r\n                            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\r\n                                // Must include lastMultiDragSelect (select it), in case modified selection from no selection\r\n                                // (but previous selection existed)\r\n                                var n, i;\r\n\r\n                                if (currentIndex > lastIndex) {\r\n                                    i = lastIndex;\r\n                                    n = currentIndex;\r\n                                } else {\r\n                                    i = currentIndex;\r\n                                    n = lastIndex + 1;\r\n                                }\r\n\r\n                                for (; i < n; i++) {\r\n                                    if (~multiDragElements.indexOf(children[i])) continue;\r\n                                    toggleClass(children[i], options.selectedClass, true);\r\n                                    multiDragElements.push(children[i]);\r\n                                    dispatchEvent({\r\n                                        sortable: sortable,\r\n                                        rootEl: rootEl,\r\n                                        name: 'select',\r\n                                        targetEl: children[i],\r\n                                        originalEvt: evt\r\n                                    });\r\n                                }\r\n                            }\r\n                        } else {\r\n                            lastMultiDragSelect = dragEl$1;\r\n                        }\r\n\r\n                        multiDragSortable = toSortable;\r\n                    } else {\r\n                        multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\r\n                        lastMultiDragSelect = null;\r\n                        dispatchEvent({\r\n                            sortable: sortable,\r\n                            rootEl: rootEl,\r\n                            name: 'deselect',\r\n                            targetEl: dragEl$1,\r\n                            originalEvt: evt\r\n                        });\r\n                    }\r\n                } // Multi-drag drop\r\n\r\n\r\n                if (dragStarted && this.isMultiDrag) {\r\n                    // Do not \"unfold\" after around dragEl if reverted\r\n                    if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\r\n                        var dragRect = getRect(dragEl$1),\r\n                            multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\r\n                        if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\r\n                        toSortable.captureAnimationState();\r\n\r\n                        if (!initialFolding) {\r\n                            if (options.animation) {\r\n                                dragEl$1.fromRect = dragRect;\r\n                                multiDragElements.forEach(function (multiDragElement) {\r\n                                    multiDragElement.thisAnimationDuration = null;\r\n\r\n                                    if (multiDragElement !== dragEl$1) {\r\n                                        var rect = folding ? getRect(multiDragElement) : dragRect;\r\n                                        multiDragElement.fromRect = rect; // Prepare unfold animation\r\n\r\n                                        toSortable.addAnimationState({\r\n                                            target: multiDragElement,\r\n                                            rect: rect\r\n                                        });\r\n                                    }\r\n                                });\r\n                            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\r\n                            // properly they must all be removed\r\n\r\n\r\n                            removeMultiDragElements();\r\n                            multiDragElements.forEach(function (multiDragElement) {\r\n                                if (children[multiDragIndex]) {\r\n                                    parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\r\n                                } else {\r\n                                    parentEl.appendChild(multiDragElement);\r\n                                }\r\n\r\n                                multiDragIndex++;\r\n                            }); // If initial folding is done, the elements may have changed position because they are now\r\n                            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\r\n                            // must be fired here as Sortable will not.\r\n\r\n                            if (oldIndex === index(dragEl$1)) {\r\n                                var update = false;\r\n                                multiDragElements.forEach(function (multiDragElement) {\r\n                                    if (multiDragElement.sortableIndex !== index(multiDragElement)) {\r\n                                        update = true;\r\n                                        return;\r\n                                    }\r\n                                });\r\n\r\n                                if (update) {\r\n                                    dispatchSortableEvent('update');\r\n                                }\r\n                            }\r\n                        } // Must be done after capturing individual rects (scroll bar)\r\n\r\n\r\n                        multiDragElements.forEach(function (multiDragElement) {\r\n                            unsetRect(multiDragElement);\r\n                        });\r\n                        toSortable.animateAll();\r\n                    }\r\n\r\n                    multiDragSortable = toSortable;\r\n                } // Remove clones if necessary\r\n\r\n\r\n                if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\r\n                    multiDragClones.forEach(function (clone) {\r\n                        clone.parentNode && clone.parentNode.removeChild(clone);\r\n                    });\r\n                }\r\n            },\r\n            nullingGlobal: function nullingGlobal() {\r\n                this.isMultiDrag = dragStarted = false;\r\n                multiDragClones.length = 0;\r\n            },\r\n            destroyGlobal: function destroyGlobal() {\r\n                this._deselectMultiDrag();\r\n\r\n                off(document, 'pointerup', this._deselectMultiDrag);\r\n                off(document, 'mouseup', this._deselectMultiDrag);\r\n                off(document, 'touchend', this._deselectMultiDrag);\r\n                off(document, 'keydown', this._checkKeyDown);\r\n                off(document, 'keyup', this._checkKeyUp);\r\n            },\r\n            _deselectMultiDrag: function _deselectMultiDrag(evt) {\r\n                if (typeof dragStarted !== \"undefined\" && dragStarted) return; // Only deselect if selection is in this sortable\r\n\r\n                if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable\r\n\r\n                if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click\r\n\r\n                if (evt && evt.button !== 0) return;\r\n\r\n                while (multiDragElements.length) {\r\n                    var el = multiDragElements[0];\r\n                    toggleClass(el, this.options.selectedClass, false);\r\n                    multiDragElements.shift();\r\n                    dispatchEvent({\r\n                        sortable: this.sortable,\r\n                        rootEl: this.sortable.el,\r\n                        name: 'deselect',\r\n                        targetEl: el,\r\n                        originalEvt: evt\r\n                    });\r\n                }\r\n            },\r\n            _checkKeyDown: function _checkKeyDown(evt) {\r\n                if (evt.key === this.options.multiDragKey) {\r\n                    this.multiDragKeyDown = true;\r\n                }\r\n            },\r\n            _checkKeyUp: function _checkKeyUp(evt) {\r\n                if (evt.key === this.options.multiDragKey) {\r\n                    this.multiDragKeyDown = false;\r\n                }\r\n            }\r\n        };\r\n        return _extends(MultiDrag, {\r\n            // Static methods & properties\r\n            pluginName: 'multiDrag',\r\n            utils: {\r\n                /**\r\n                 * Selects the provided multi-drag item\r\n                 * @param  {HTMLElement} el    The element to be selected\r\n                 */\r\n                select: function select(el) {\r\n                    var sortable = el.parentNode[expando];\r\n                    if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\r\n\r\n                    if (multiDragSortable && multiDragSortable !== sortable) {\r\n                        multiDragSortable.multiDrag._deselectMultiDrag();\r\n\r\n                        multiDragSortable = sortable;\r\n                    }\r\n\r\n                    toggleClass(el, sortable.options.selectedClass, true);\r\n                    multiDragElements.push(el);\r\n                },\r\n\r\n                /**\r\n                 * Deselects the provided multi-drag item\r\n                 * @param  {HTMLElement} el    The element to be deselected\r\n                 */\r\n                deselect: function deselect(el) {\r\n                    var sortable = el.parentNode[expando],\r\n                        index = multiDragElements.indexOf(el);\r\n                    if (!sortable || !sortable.options.multiDrag || !~index) return;\r\n                    toggleClass(el, sortable.options.selectedClass, false);\r\n                    multiDragElements.splice(index, 1);\r\n                }\r\n            },\r\n            eventProperties: function eventProperties() {\r\n                var _this3 = this;\r\n\r\n                var oldIndicies = [],\r\n                    newIndicies = [];\r\n                multiDragElements.forEach(function (multiDragElement) {\r\n                    oldIndicies.push({\r\n                        multiDragElement: multiDragElement,\r\n                        index: multiDragElement.sortableIndex\r\n                    }); // multiDragElements will already be sorted if folding\r\n\r\n                    var newIndex;\r\n\r\n                    if (folding && multiDragElement !== dragEl$1) {\r\n                        newIndex = -1;\r\n                    } else if (folding) {\r\n                        newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\r\n                    } else {\r\n                        newIndex = index(multiDragElement);\r\n                    }\r\n\r\n                    newIndicies.push({\r\n                        multiDragElement: multiDragElement,\r\n                        index: newIndex\r\n                    });\r\n                });\r\n                return {\r\n                    items: _toConsumableArray(multiDragElements),\r\n                    clones: [].concat(multiDragClones),\r\n                    oldIndicies: oldIndicies,\r\n                    newIndicies: newIndicies\r\n                };\r\n            },\r\n            optionListeners: {\r\n                multiDragKey: function multiDragKey(key) {\r\n                    key = key.toLowerCase();\r\n\r\n                    if (key === 'ctrl') {\r\n                        key = 'Control';\r\n                    } else if (key.length > 1) {\r\n                        key = key.charAt(0).toUpperCase() + key.substr(1);\r\n                    }\r\n\r\n                    return key;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    function insertMultiDragElements(clonesInserted, rootEl) {\r\n        multiDragElements.forEach(function (multiDragElement, i) {\r\n            var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\r\n\r\n            if (target) {\r\n                rootEl.insertBefore(multiDragElement, target);\r\n            } else {\r\n                rootEl.appendChild(multiDragElement);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Insert multi-drag clones\r\n     * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\r\n     * @param  {HTMLElement} rootEl\r\n     */\r\n\r\n\r\n    function insertMultiDragClones(elementsInserted, rootEl) {\r\n        multiDragClones.forEach(function (clone, i) {\r\n            var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\r\n\r\n            if (target) {\r\n                rootEl.insertBefore(clone, target);\r\n            } else {\r\n                rootEl.appendChild(clone);\r\n            }\r\n        });\r\n    }\r\n\r\n    function removeMultiDragElements() {\r\n        multiDragElements.forEach(function (multiDragElement) {\r\n            if (multiDragElement === dragEl$1) return;\r\n            multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\r\n        });\r\n    }\r\n\r\n    Sortable.mount(new AutoScrollPlugin());\r\n    Sortable.mount(Remove, Revert);\r\n\r\n    Sortable.mount(new SwapPlugin());\r\n    Sortable.mount(new MultiDragPlugin());\r\n\r\n    return Sortable;\r\n\r\n}));"],"file":"dragSort.js"}